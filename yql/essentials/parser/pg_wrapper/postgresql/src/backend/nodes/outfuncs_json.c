#include "postgres.h"

#include <ctype.h>

#include "access/attnum.h"
#include "common/shortest_dec.h"
#include "lib/stringinfo.h"
#include "miscadmin.h"
#include "nodes/bitmapset.h"
#include "nodes/nodes.h"
#include "nodes/pg_list.h"
#include "utils/datum.h"
#include "access/amapi.h"
#include "access/sdir.h"
#include "access/tableam.h"
#include "access/tsmapi.h"
#include "commands/event_trigger.h"
#include "commands/trigger.h"
#include "executor/tuptable.h"
#include "foreign/fdwapi.h"
#include "nodes/bitmapset.h"
#include "nodes/execnodes.h"
#include "nodes/extensible.h"
#include "nodes/lockoptions.h"
#include "nodes/miscnodes.h"
#include "nodes/nodes.h"
#include "nodes/parsenodes.h"
#include "nodes/pathnodes.h"
#include "nodes/plannodes.h"
#include "nodes/primnodes.h"
#include "nodes/replnodes.h"
#include "nodes/supportnodes.h"
#include "nodes/value.h"
#include "utils/rel.h"

static void outChar(StringInfo str, char c);
static void outDouble(StringInfo str, double d);


#define booltostr(x)	((x) ? "true" : "false")

static void
removeTrailingDelimiter(StringInfo str)
{
	if (str->len >= 1 && str->data[str->len - 1] == ',') {
		str->len -= 1;
		str->data[str->len] = '\0';
	}
}

static void
_outToken(StringInfo buf, const char *str)
{
	if (str == NULL)
	{
		appendStringInfoString(buf, "null");
		return;
	}

	// copied directly from https://github.com/postgres/postgres/blob/master/src/backend/utils/adt/json.c#L2428
	const char *p;

	appendStringInfoCharMacro(buf, '"');
	for (p = str; *p; p++)
	{
		switch (*p)
		{
			case '\b':
				appendStringInfoString(buf, "\\b");
				break;
			case '\f':
				appendStringInfoString(buf, "\\f");
				break;
			case '\n':
				appendStringInfoString(buf, "\\n");
				break;
			case '\r':
				appendStringInfoString(buf, "\\r");
				break;
			case '\t':
				appendStringInfoString(buf, "\\t");
				break;
			case '"':
				appendStringInfoString(buf, "\\\"");
				break;
			case '\\':
				appendStringInfoString(buf, "\\\\");
				break;
			default:
				if ((unsigned char) *p < ' ' || *p == '<' || *p == '>')
					appendStringInfo(buf, "\\u%04x", (int) *p);
				else
					appendStringInfoCharMacro(buf, *p);
				break;
		}
	}
	appendStringInfoCharMacro(buf, '"');
}

// This file is autogenerated by ./scripts/generate_protobuf_and_funcs.rb

static const char*
_enumToStringQuerySource(QuerySource value) {
  switch(value) {
    case QSRC_ORIGINAL: return "QSRC_ORIGINAL";
    case QSRC_PARSER: return "QSRC_PARSER";
    case QSRC_INSTEAD_RULE: return "QSRC_INSTEAD_RULE";
    case QSRC_QUAL_INSTEAD_RULE: return "QSRC_QUAL_INSTEAD_RULE";
    case QSRC_NON_INSTEAD_RULE: return "QSRC_NON_INSTEAD_RULE";
  }
  Assert(false);
  return NULL;
}

static const char*
_enumToStringSortByDir(SortByDir value) {
  switch(value) {
    case SORTBY_DEFAULT: return "SORTBY_DEFAULT";
    case SORTBY_ASC: return "SORTBY_ASC";
    case SORTBY_DESC: return "SORTBY_DESC";
    case SORTBY_USING: return "SORTBY_USING";
  }
  Assert(false);
  return NULL;
}

static const char*
_enumToStringSortByNulls(SortByNulls value) {
  switch(value) {
    case SORTBY_NULLS_DEFAULT: return "SORTBY_NULLS_DEFAULT";
    case SORTBY_NULLS_FIRST: return "SORTBY_NULLS_FIRST";
    case SORTBY_NULLS_LAST: return "SORTBY_NULLS_LAST";
  }
  Assert(false);
  return NULL;
}

static const char*
_enumToStringSetQuantifier(SetQuantifier value) {
  switch(value) {
    case SET_QUANTIFIER_DEFAULT: return "SET_QUANTIFIER_DEFAULT";
    case SET_QUANTIFIER_ALL: return "SET_QUANTIFIER_ALL";
    case SET_QUANTIFIER_DISTINCT: return "SET_QUANTIFIER_DISTINCT";
  }
  Assert(false);
  return NULL;
}

static const char*
_enumToStringA_Expr_Kind(A_Expr_Kind value) {
  switch(value) {
    case AEXPR_OP: return "AEXPR_OP";
    case AEXPR_OP_ANY: return "AEXPR_OP_ANY";
    case AEXPR_OP_ALL: return "AEXPR_OP_ALL";
    case AEXPR_DISTINCT: return "AEXPR_DISTINCT";
    case AEXPR_NOT_DISTINCT: return "AEXPR_NOT_DISTINCT";
    case AEXPR_NULLIF: return "AEXPR_NULLIF";
    case AEXPR_IN: return "AEXPR_IN";
    case AEXPR_LIKE: return "AEXPR_LIKE";
    case AEXPR_ILIKE: return "AEXPR_ILIKE";
    case AEXPR_SIMILAR: return "AEXPR_SIMILAR";
    case AEXPR_BETWEEN: return "AEXPR_BETWEEN";
    case AEXPR_NOT_BETWEEN: return "AEXPR_NOT_BETWEEN";
    case AEXPR_BETWEEN_SYM: return "AEXPR_BETWEEN_SYM";
    case AEXPR_NOT_BETWEEN_SYM: return "AEXPR_NOT_BETWEEN_SYM";
  }
  Assert(false);
  return NULL;
}

static const char*
_enumToStringRoleSpecType(RoleSpecType value) {
  switch(value) {
    case ROLESPEC_CSTRING: return "ROLESPEC_CSTRING";
    case ROLESPEC_CURRENT_ROLE: return "ROLESPEC_CURRENT_ROLE";
    case ROLESPEC_CURRENT_USER: return "ROLESPEC_CURRENT_USER";
    case ROLESPEC_SESSION_USER: return "ROLESPEC_SESSION_USER";
    case ROLESPEC_PUBLIC: return "ROLESPEC_PUBLIC";
  }
  Assert(false);
  return NULL;
}

static const char*
_enumToStringTableLikeOption(TableLikeOption value) {
  switch(value) {
    case CREATE_TABLE_LIKE_COMMENTS: return "CREATE_TABLE_LIKE_COMMENTS";
    case CREATE_TABLE_LIKE_COMPRESSION: return "CREATE_TABLE_LIKE_COMPRESSION";
    case CREATE_TABLE_LIKE_CONSTRAINTS: return "CREATE_TABLE_LIKE_CONSTRAINTS";
    case CREATE_TABLE_LIKE_DEFAULTS: return "CREATE_TABLE_LIKE_DEFAULTS";
    case CREATE_TABLE_LIKE_GENERATED: return "CREATE_TABLE_LIKE_GENERATED";
    case CREATE_TABLE_LIKE_IDENTITY: return "CREATE_TABLE_LIKE_IDENTITY";
    case CREATE_TABLE_LIKE_INDEXES: return "CREATE_TABLE_LIKE_INDEXES";
    case CREATE_TABLE_LIKE_STATISTICS: return "CREATE_TABLE_LIKE_STATISTICS";
    case CREATE_TABLE_LIKE_STORAGE: return "CREATE_TABLE_LIKE_STORAGE";
    case CREATE_TABLE_LIKE_ALL: return "CREATE_TABLE_LIKE_ALL";
  }
  Assert(false);
  return NULL;
}

static const char*
_enumToStringDefElemAction(DefElemAction value) {
  switch(value) {
    case DEFELEM_UNSPEC: return "DEFELEM_UNSPEC";
    case DEFELEM_SET: return "DEFELEM_SET";
    case DEFELEM_ADD: return "DEFELEM_ADD";
    case DEFELEM_DROP: return "DEFELEM_DROP";
  }
  Assert(false);
  return NULL;
}

static const char*
_enumToStringPartitionStrategy(PartitionStrategy value) {
  switch(value) {
    case PARTITION_STRATEGY_LIST: return "PARTITION_STRATEGY_LIST";
    case PARTITION_STRATEGY_RANGE: return "PARTITION_STRATEGY_RANGE";
    case PARTITION_STRATEGY_HASH: return "PARTITION_STRATEGY_HASH";
  }
  Assert(false);
  return NULL;
}

static const char*
_enumToStringPartitionRangeDatumKind(PartitionRangeDatumKind value) {
  switch(value) {
    case PARTITION_RANGE_DATUM_MINVALUE: return "PARTITION_RANGE_DATUM_MINVALUE";
    case PARTITION_RANGE_DATUM_VALUE: return "PARTITION_RANGE_DATUM_VALUE";
    case PARTITION_RANGE_DATUM_MAXVALUE: return "PARTITION_RANGE_DATUM_MAXVALUE";
  }
  Assert(false);
  return NULL;
}

static const char*
_enumToStringRTEKind(RTEKind value) {
  switch(value) {
    case RTE_RELATION: return "RTE_RELATION";
    case RTE_SUBQUERY: return "RTE_SUBQUERY";
    case RTE_JOIN: return "RTE_JOIN";
    case RTE_FUNCTION: return "RTE_FUNCTION";
    case RTE_TABLEFUNC: return "RTE_TABLEFUNC";
    case RTE_VALUES: return "RTE_VALUES";
    case RTE_CTE: return "RTE_CTE";
    case RTE_NAMEDTUPLESTORE: return "RTE_NAMEDTUPLESTORE";
    case RTE_RESULT: return "RTE_RESULT";
  }
  Assert(false);
  return NULL;
}

static const char*
_enumToStringWCOKind(WCOKind value) {
  switch(value) {
    case WCO_VIEW_CHECK: return "WCO_VIEW_CHECK";
    case WCO_RLS_INSERT_CHECK: return "WCO_RLS_INSERT_CHECK";
    case WCO_RLS_UPDATE_CHECK: return "WCO_RLS_UPDATE_CHECK";
    case WCO_RLS_CONFLICT_CHECK: return "WCO_RLS_CONFLICT_CHECK";
    case WCO_RLS_MERGE_UPDATE_CHECK: return "WCO_RLS_MERGE_UPDATE_CHECK";
    case WCO_RLS_MERGE_DELETE_CHECK: return "WCO_RLS_MERGE_DELETE_CHECK";
  }
  Assert(false);
  return NULL;
}

static const char*
_enumToStringGroupingSetKind(GroupingSetKind value) {
  switch(value) {
    case GROUPING_SET_EMPTY: return "GROUPING_SET_EMPTY";
    case GROUPING_SET_SIMPLE: return "GROUPING_SET_SIMPLE";
    case GROUPING_SET_ROLLUP: return "GROUPING_SET_ROLLUP";
    case GROUPING_SET_CUBE: return "GROUPING_SET_CUBE";
    case GROUPING_SET_SETS: return "GROUPING_SET_SETS";
  }
  Assert(false);
  return NULL;
}

static const char*
_enumToStringCTEMaterialize(CTEMaterialize value) {
  switch(value) {
    case CTEMaterializeDefault: return "CTEMaterializeDefault";
    case CTEMaterializeAlways: return "CTEMaterializeAlways";
    case CTEMaterializeNever: return "CTEMaterializeNever";
  }
  Assert(false);
  return NULL;
}

static const char*
_enumToStringSetOperation(SetOperation value) {
  switch(value) {
    case SETOP_NONE: return "SETOP_NONE";
    case SETOP_UNION: return "SETOP_UNION";
    case SETOP_INTERSECT: return "SETOP_INTERSECT";
    case SETOP_EXCEPT: return "SETOP_EXCEPT";
  }
  Assert(false);
  return NULL;
}

static const char*
_enumToStringObjectType(ObjectType value) {
  switch(value) {
    case OBJECT_ACCESS_METHOD: return "OBJECT_ACCESS_METHOD";
    case OBJECT_AGGREGATE: return "OBJECT_AGGREGATE";
    case OBJECT_AMOP: return "OBJECT_AMOP";
    case OBJECT_AMPROC: return "OBJECT_AMPROC";
    case OBJECT_ATTRIBUTE: return "OBJECT_ATTRIBUTE";
    case OBJECT_CAST: return "OBJECT_CAST";
    case OBJECT_COLUMN: return "OBJECT_COLUMN";
    case OBJECT_COLLATION: return "OBJECT_COLLATION";
    case OBJECT_CONVERSION: return "OBJECT_CONVERSION";
    case OBJECT_DATABASE: return "OBJECT_DATABASE";
    case OBJECT_DEFAULT: return "OBJECT_DEFAULT";
    case OBJECT_DEFACL: return "OBJECT_DEFACL";
    case OBJECT_DOMAIN: return "OBJECT_DOMAIN";
    case OBJECT_DOMCONSTRAINT: return "OBJECT_DOMCONSTRAINT";
    case OBJECT_EVENT_TRIGGER: return "OBJECT_EVENT_TRIGGER";
    case OBJECT_EXTENSION: return "OBJECT_EXTENSION";
    case OBJECT_FDW: return "OBJECT_FDW";
    case OBJECT_FOREIGN_SERVER: return "OBJECT_FOREIGN_SERVER";
    case OBJECT_FOREIGN_TABLE: return "OBJECT_FOREIGN_TABLE";
    case OBJECT_FUNCTION: return "OBJECT_FUNCTION";
    case OBJECT_INDEX: return "OBJECT_INDEX";
    case OBJECT_LANGUAGE: return "OBJECT_LANGUAGE";
    case OBJECT_LARGEOBJECT: return "OBJECT_LARGEOBJECT";
    case OBJECT_MATVIEW: return "OBJECT_MATVIEW";
    case OBJECT_OPCLASS: return "OBJECT_OPCLASS";
    case OBJECT_OPERATOR: return "OBJECT_OPERATOR";
    case OBJECT_OPFAMILY: return "OBJECT_OPFAMILY";
    case OBJECT_PARAMETER_ACL: return "OBJECT_PARAMETER_ACL";
    case OBJECT_POLICY: return "OBJECT_POLICY";
    case OBJECT_PROCEDURE: return "OBJECT_PROCEDURE";
    case OBJECT_PUBLICATION: return "OBJECT_PUBLICATION";
    case OBJECT_PUBLICATION_NAMESPACE: return "OBJECT_PUBLICATION_NAMESPACE";
    case OBJECT_PUBLICATION_REL: return "OBJECT_PUBLICATION_REL";
    case OBJECT_ROLE: return "OBJECT_ROLE";
    case OBJECT_ROUTINE: return "OBJECT_ROUTINE";
    case OBJECT_RULE: return "OBJECT_RULE";
    case OBJECT_SCHEMA: return "OBJECT_SCHEMA";
    case OBJECT_SEQUENCE: return "OBJECT_SEQUENCE";
    case OBJECT_SUBSCRIPTION: return "OBJECT_SUBSCRIPTION";
    case OBJECT_STATISTIC_EXT: return "OBJECT_STATISTIC_EXT";
    case OBJECT_TABCONSTRAINT: return "OBJECT_TABCONSTRAINT";
    case OBJECT_TABLE: return "OBJECT_TABLE";
    case OBJECT_TABLESPACE: return "OBJECT_TABLESPACE";
    case OBJECT_TRANSFORM: return "OBJECT_TRANSFORM";
    case OBJECT_TRIGGER: return "OBJECT_TRIGGER";
    case OBJECT_TSCONFIGURATION: return "OBJECT_TSCONFIGURATION";
    case OBJECT_TSDICTIONARY: return "OBJECT_TSDICTIONARY";
    case OBJECT_TSPARSER: return "OBJECT_TSPARSER";
    case OBJECT_TSTEMPLATE: return "OBJECT_TSTEMPLATE";
    case OBJECT_TYPE: return "OBJECT_TYPE";
    case OBJECT_USER_MAPPING: return "OBJECT_USER_MAPPING";
    case OBJECT_VIEW: return "OBJECT_VIEW";
  }
  Assert(false);
  return NULL;
}

static const char*
_enumToStringDropBehavior(DropBehavior value) {
  switch(value) {
    case DROP_RESTRICT: return "DROP_RESTRICT";
    case DROP_CASCADE: return "DROP_CASCADE";
  }
  Assert(false);
  return NULL;
}

static const char*
_enumToStringGrantTargetType(GrantTargetType value) {
  switch(value) {
    case ACL_TARGET_OBJECT: return "ACL_TARGET_OBJECT";
    case ACL_TARGET_ALL_IN_SCHEMA: return "ACL_TARGET_ALL_IN_SCHEMA";
    case ACL_TARGET_DEFAULTS: return "ACL_TARGET_DEFAULTS";
  }
  Assert(false);
  return NULL;
}

static const char*
_enumToStringVariableSetKind(VariableSetKind value) {
  switch(value) {
    case VAR_SET_VALUE: return "VAR_SET_VALUE";
    case VAR_SET_DEFAULT: return "VAR_SET_DEFAULT";
    case VAR_SET_CURRENT: return "VAR_SET_CURRENT";
    case VAR_SET_MULTI: return "VAR_SET_MULTI";
    case VAR_RESET: return "VAR_RESET";
    case VAR_RESET_ALL: return "VAR_RESET_ALL";
  }
  Assert(false);
  return NULL;
}

static const char*
_enumToStringConstrType(ConstrType value) {
  switch(value) {
    case CONSTR_NULL: return "CONSTR_NULL";
    case CONSTR_NOTNULL: return "CONSTR_NOTNULL";
    case CONSTR_DEFAULT: return "CONSTR_DEFAULT";
    case CONSTR_IDENTITY: return "CONSTR_IDENTITY";
    case CONSTR_GENERATED: return "CONSTR_GENERATED";
    case CONSTR_CHECK: return "CONSTR_CHECK";
    case CONSTR_PRIMARY: return "CONSTR_PRIMARY";
    case CONSTR_UNIQUE: return "CONSTR_UNIQUE";
    case CONSTR_EXCLUSION: return "CONSTR_EXCLUSION";
    case CONSTR_FOREIGN: return "CONSTR_FOREIGN";
    case CONSTR_ATTR_DEFERRABLE: return "CONSTR_ATTR_DEFERRABLE";
    case CONSTR_ATTR_NOT_DEFERRABLE: return "CONSTR_ATTR_NOT_DEFERRABLE";
    case CONSTR_ATTR_DEFERRED: return "CONSTR_ATTR_DEFERRED";
    case CONSTR_ATTR_IMMEDIATE: return "CONSTR_ATTR_IMMEDIATE";
  }
  Assert(false);
  return NULL;
}

static const char*
_enumToStringImportForeignSchemaType(ImportForeignSchemaType value) {
  switch(value) {
    case FDW_IMPORT_SCHEMA_ALL: return "FDW_IMPORT_SCHEMA_ALL";
    case FDW_IMPORT_SCHEMA_LIMIT_TO: return "FDW_IMPORT_SCHEMA_LIMIT_TO";
    case FDW_IMPORT_SCHEMA_EXCEPT: return "FDW_IMPORT_SCHEMA_EXCEPT";
  }
  Assert(false);
  return NULL;
}

static const char*
_enumToStringRoleStmtType(RoleStmtType value) {
  switch(value) {
    case ROLESTMT_ROLE: return "ROLESTMT_ROLE";
    case ROLESTMT_USER: return "ROLESTMT_USER";
    case ROLESTMT_GROUP: return "ROLESTMT_GROUP";
  }
  Assert(false);
  return NULL;
}

static const char*
_enumToStringFetchDirection(FetchDirection value) {
  switch(value) {
    case FETCH_FORWARD: return "FETCH_FORWARD";
    case FETCH_BACKWARD: return "FETCH_BACKWARD";
    case FETCH_ABSOLUTE: return "FETCH_ABSOLUTE";
    case FETCH_RELATIVE: return "FETCH_RELATIVE";
  }
  Assert(false);
  return NULL;
}

static const char*
_enumToStringFunctionParameterMode(FunctionParameterMode value) {
  switch(value) {
    case FUNC_PARAM_IN: return "FUNC_PARAM_IN";
    case FUNC_PARAM_OUT: return "FUNC_PARAM_OUT";
    case FUNC_PARAM_INOUT: return "FUNC_PARAM_INOUT";
    case FUNC_PARAM_VARIADIC: return "FUNC_PARAM_VARIADIC";
    case FUNC_PARAM_TABLE: return "FUNC_PARAM_TABLE";
    case FUNC_PARAM_DEFAULT: return "FUNC_PARAM_DEFAULT";
  }
  Assert(false);
  return NULL;
}

static const char*
_enumToStringTransactionStmtKind(TransactionStmtKind value) {
  switch(value) {
    case TRANS_STMT_BEGIN: return "TRANS_STMT_BEGIN";
    case TRANS_STMT_START: return "TRANS_STMT_START";
    case TRANS_STMT_COMMIT: return "TRANS_STMT_COMMIT";
    case TRANS_STMT_ROLLBACK: return "TRANS_STMT_ROLLBACK";
    case TRANS_STMT_SAVEPOINT: return "TRANS_STMT_SAVEPOINT";
    case TRANS_STMT_RELEASE: return "TRANS_STMT_RELEASE";
    case TRANS_STMT_ROLLBACK_TO: return "TRANS_STMT_ROLLBACK_TO";
    case TRANS_STMT_PREPARE: return "TRANS_STMT_PREPARE";
    case TRANS_STMT_COMMIT_PREPARED: return "TRANS_STMT_COMMIT_PREPARED";
    case TRANS_STMT_ROLLBACK_PREPARED: return "TRANS_STMT_ROLLBACK_PREPARED";
  }
  Assert(false);
  return NULL;
}

static const char*
_enumToStringViewCheckOption(ViewCheckOption value) {
  switch(value) {
    case NO_CHECK_OPTION: return "NO_CHECK_OPTION";
    case LOCAL_CHECK_OPTION: return "LOCAL_CHECK_OPTION";
    case CASCADED_CHECK_OPTION: return "CASCADED_CHECK_OPTION";
  }
  Assert(false);
  return NULL;
}

static const char*
_enumToStringDiscardMode(DiscardMode value) {
  switch(value) {
    case DISCARD_ALL: return "DISCARD_ALL";
    case DISCARD_PLANS: return "DISCARD_PLANS";
    case DISCARD_SEQUENCES: return "DISCARD_SEQUENCES";
    case DISCARD_TEMP: return "DISCARD_TEMP";
  }
  Assert(false);
  return NULL;
}

static const char*
_enumToStringReindexObjectType(ReindexObjectType value) {
  switch(value) {
    case REINDEX_OBJECT_INDEX: return "REINDEX_OBJECT_INDEX";
    case REINDEX_OBJECT_TABLE: return "REINDEX_OBJECT_TABLE";
    case REINDEX_OBJECT_SCHEMA: return "REINDEX_OBJECT_SCHEMA";
    case REINDEX_OBJECT_SYSTEM: return "REINDEX_OBJECT_SYSTEM";
    case REINDEX_OBJECT_DATABASE: return "REINDEX_OBJECT_DATABASE";
  }
  Assert(false);
  return NULL;
}

static const char*
_enumToStringAlterTSConfigType(AlterTSConfigType value) {
  switch(value) {
    case ALTER_TSCONFIG_ADD_MAPPING: return "ALTER_TSCONFIG_ADD_MAPPING";
    case ALTER_TSCONFIG_ALTER_MAPPING_FOR_TOKEN: return "ALTER_TSCONFIG_ALTER_MAPPING_FOR_TOKEN";
    case ALTER_TSCONFIG_REPLACE_DICT: return "ALTER_TSCONFIG_REPLACE_DICT";
    case ALTER_TSCONFIG_REPLACE_DICT_FOR_TOKEN: return "ALTER_TSCONFIG_REPLACE_DICT_FOR_TOKEN";
    case ALTER_TSCONFIG_DROP_MAPPING: return "ALTER_TSCONFIG_DROP_MAPPING";
  }
  Assert(false);
  return NULL;
}

static const char*
_enumToStringPublicationObjSpecType(PublicationObjSpecType value) {
  switch(value) {
    case PUBLICATIONOBJ_TABLE: return "PUBLICATIONOBJ_TABLE";
    case PUBLICATIONOBJ_TABLES_IN_SCHEMA: return "PUBLICATIONOBJ_TABLES_IN_SCHEMA";
    case PUBLICATIONOBJ_TABLES_IN_CUR_SCHEMA: return "PUBLICATIONOBJ_TABLES_IN_CUR_SCHEMA";
    case PUBLICATIONOBJ_CONTINUATION: return "PUBLICATIONOBJ_CONTINUATION";
  }
  Assert(false);
  return NULL;
}

static const char*
_enumToStringAlterPublicationAction(AlterPublicationAction value) {
  switch(value) {
    case AP_AddObjects: return "AP_AddObjects";
    case AP_DropObjects: return "AP_DropObjects";
    case AP_SetObjects: return "AP_SetObjects";
  }
  Assert(false);
  return NULL;
}

static const char*
_enumToStringAlterSubscriptionType(AlterSubscriptionType value) {
  switch(value) {
    case ALTER_SUBSCRIPTION_OPTIONS: return "ALTER_SUBSCRIPTION_OPTIONS";
    case ALTER_SUBSCRIPTION_CONNECTION: return "ALTER_SUBSCRIPTION_CONNECTION";
    case ALTER_SUBSCRIPTION_SET_PUBLICATION: return "ALTER_SUBSCRIPTION_SET_PUBLICATION";
    case ALTER_SUBSCRIPTION_ADD_PUBLICATION: return "ALTER_SUBSCRIPTION_ADD_PUBLICATION";
    case ALTER_SUBSCRIPTION_DROP_PUBLICATION: return "ALTER_SUBSCRIPTION_DROP_PUBLICATION";
    case ALTER_SUBSCRIPTION_REFRESH: return "ALTER_SUBSCRIPTION_REFRESH";
    case ALTER_SUBSCRIPTION_ENABLED: return "ALTER_SUBSCRIPTION_ENABLED";
    case ALTER_SUBSCRIPTION_SKIP: return "ALTER_SUBSCRIPTION_SKIP";
  }
  Assert(false);
  return NULL;
}

static const char*
_enumToStringOverridingKind(OverridingKind value) {
  switch(value) {
    case OVERRIDING_NOT_SET: return "OVERRIDING_NOT_SET";
    case OVERRIDING_USER_VALUE: return "OVERRIDING_USER_VALUE";
    case OVERRIDING_SYSTEM_VALUE: return "OVERRIDING_SYSTEM_VALUE";
  }
  Assert(false);
  return NULL;
}

static const char*
_enumToStringOnCommitAction(OnCommitAction value) {
  switch(value) {
    case ONCOMMIT_NOOP: return "ONCOMMIT_NOOP";
    case ONCOMMIT_PRESERVE_ROWS: return "ONCOMMIT_PRESERVE_ROWS";
    case ONCOMMIT_DELETE_ROWS: return "ONCOMMIT_DELETE_ROWS";
    case ONCOMMIT_DROP: return "ONCOMMIT_DROP";
  }
  Assert(false);
  return NULL;
}

static const char*
_enumToStringParamKind(ParamKind value) {
  switch(value) {
    case PARAM_EXTERN: return "PARAM_EXTERN";
    case PARAM_EXEC: return "PARAM_EXEC";
    case PARAM_SUBLINK: return "PARAM_SUBLINK";
    case PARAM_MULTIEXPR: return "PARAM_MULTIEXPR";
  }
  Assert(false);
  return NULL;
}

static const char*
_enumToStringCoercionContext(CoercionContext value) {
  switch(value) {
    case COERCION_IMPLICIT: return "COERCION_IMPLICIT";
    case COERCION_ASSIGNMENT: return "COERCION_ASSIGNMENT";
    case COERCION_PLPGSQL: return "COERCION_PLPGSQL";
    case COERCION_EXPLICIT: return "COERCION_EXPLICIT";
  }
  Assert(false);
  return NULL;
}

static const char*
_enumToStringCoercionForm(CoercionForm value) {
  switch(value) {
    case COERCE_EXPLICIT_CALL: return "COERCE_EXPLICIT_CALL";
    case COERCE_EXPLICIT_CAST: return "COERCE_EXPLICIT_CAST";
    case COERCE_IMPLICIT_CAST: return "COERCE_IMPLICIT_CAST";
    case COERCE_SQL_SYNTAX: return "COERCE_SQL_SYNTAX";
  }
  Assert(false);
  return NULL;
}

static const char*
_enumToStringBoolExprType(BoolExprType value) {
  switch(value) {
    case AND_EXPR: return "AND_EXPR";
    case OR_EXPR: return "OR_EXPR";
    case NOT_EXPR: return "NOT_EXPR";
  }
  Assert(false);
  return NULL;
}

static const char*
_enumToStringSubLinkType(SubLinkType value) {
  switch(value) {
    case EXISTS_SUBLINK: return "EXISTS_SUBLINK";
    case ALL_SUBLINK: return "ALL_SUBLINK";
    case ANY_SUBLINK: return "ANY_SUBLINK";
    case ROWCOMPARE_SUBLINK: return "ROWCOMPARE_SUBLINK";
    case EXPR_SUBLINK: return "EXPR_SUBLINK";
    case MULTIEXPR_SUBLINK: return "MULTIEXPR_SUBLINK";
    case ARRAY_SUBLINK: return "ARRAY_SUBLINK";
    case CTE_SUBLINK: return "CTE_SUBLINK";
  }
  Assert(false);
  return NULL;
}

static const char*
_enumToStringRowCompareType(RowCompareType value) {
  switch(value) {
    case ROWCOMPARE_LT: return "ROWCOMPARE_LT";
    case ROWCOMPARE_LE: return "ROWCOMPARE_LE";
    case ROWCOMPARE_EQ: return "ROWCOMPARE_EQ";
    case ROWCOMPARE_GE: return "ROWCOMPARE_GE";
    case ROWCOMPARE_GT: return "ROWCOMPARE_GT";
    case ROWCOMPARE_NE: return "ROWCOMPARE_NE";
  }
  Assert(false);
  return NULL;
}

static const char*
_enumToStringMinMaxOp(MinMaxOp value) {
  switch(value) {
    case IS_GREATEST: return "IS_GREATEST";
    case IS_LEAST: return "IS_LEAST";
  }
  Assert(false);
  return NULL;
}

static const char*
_enumToStringSQLValueFunctionOp(SQLValueFunctionOp value) {
  switch(value) {
    case SVFOP_CURRENT_DATE: return "SVFOP_CURRENT_DATE";
    case SVFOP_CURRENT_TIME: return "SVFOP_CURRENT_TIME";
    case SVFOP_CURRENT_TIME_N: return "SVFOP_CURRENT_TIME_N";
    case SVFOP_CURRENT_TIMESTAMP: return "SVFOP_CURRENT_TIMESTAMP";
    case SVFOP_CURRENT_TIMESTAMP_N: return "SVFOP_CURRENT_TIMESTAMP_N";
    case SVFOP_LOCALTIME: return "SVFOP_LOCALTIME";
    case SVFOP_LOCALTIME_N: return "SVFOP_LOCALTIME_N";
    case SVFOP_LOCALTIMESTAMP: return "SVFOP_LOCALTIMESTAMP";
    case SVFOP_LOCALTIMESTAMP_N: return "SVFOP_LOCALTIMESTAMP_N";
    case SVFOP_CURRENT_ROLE: return "SVFOP_CURRENT_ROLE";
    case SVFOP_CURRENT_USER: return "SVFOP_CURRENT_USER";
    case SVFOP_USER: return "SVFOP_USER";
    case SVFOP_SESSION_USER: return "SVFOP_SESSION_USER";
    case SVFOP_CURRENT_CATALOG: return "SVFOP_CURRENT_CATALOG";
    case SVFOP_CURRENT_SCHEMA: return "SVFOP_CURRENT_SCHEMA";
  }
  Assert(false);
  return NULL;
}

static const char*
_enumToStringXmlExprOp(XmlExprOp value) {
  switch(value) {
    case IS_XMLCONCAT: return "IS_XMLCONCAT";
    case IS_XMLELEMENT: return "IS_XMLELEMENT";
    case IS_XMLFOREST: return "IS_XMLFOREST";
    case IS_XMLPARSE: return "IS_XMLPARSE";
    case IS_XMLPI: return "IS_XMLPI";
    case IS_XMLROOT: return "IS_XMLROOT";
    case IS_XMLSERIALIZE: return "IS_XMLSERIALIZE";
    case IS_DOCUMENT: return "IS_DOCUMENT";
  }
  Assert(false);
  return NULL;
}

static const char*
_enumToStringXmlOptionType(XmlOptionType value) {
  switch(value) {
    case XMLOPTION_DOCUMENT: return "XMLOPTION_DOCUMENT";
    case XMLOPTION_CONTENT: return "XMLOPTION_CONTENT";
  }
  Assert(false);
  return NULL;
}

static const char*
_enumToStringJsonEncoding(JsonEncoding value) {
  switch(value) {
    case JS_ENC_DEFAULT: return "JS_ENC_DEFAULT";
    case JS_ENC_UTF8: return "JS_ENC_UTF8";
    case JS_ENC_UTF16: return "JS_ENC_UTF16";
    case JS_ENC_UTF32: return "JS_ENC_UTF32";
  }
  Assert(false);
  return NULL;
}

static const char*
_enumToStringJsonFormatType(JsonFormatType value) {
  switch(value) {
    case JS_FORMAT_DEFAULT: return "JS_FORMAT_DEFAULT";
    case JS_FORMAT_JSON: return "JS_FORMAT_JSON";
    case JS_FORMAT_JSONB: return "JS_FORMAT_JSONB";
  }
  Assert(false);
  return NULL;
}

static const char*
_enumToStringJsonValueType(JsonValueType value) {
  switch(value) {
    case JS_TYPE_ANY: return "JS_TYPE_ANY";
    case JS_TYPE_OBJECT: return "JS_TYPE_OBJECT";
    case JS_TYPE_ARRAY: return "JS_TYPE_ARRAY";
    case JS_TYPE_SCALAR: return "JS_TYPE_SCALAR";
  }
  Assert(false);
  return NULL;
}

static const char*
_enumToStringNullTestType(NullTestType value) {
  switch(value) {
    case IS_NULL: return "IS_NULL";
    case IS_NOT_NULL: return "IS_NOT_NULL";
  }
  Assert(false);
  return NULL;
}

static const char*
_enumToStringBoolTestType(BoolTestType value) {
  switch(value) {
    case IS_TRUE: return "IS_TRUE";
    case IS_NOT_TRUE: return "IS_NOT_TRUE";
    case IS_FALSE: return "IS_FALSE";
    case IS_NOT_FALSE: return "IS_NOT_FALSE";
    case IS_UNKNOWN: return "IS_UNKNOWN";
    case IS_NOT_UNKNOWN: return "IS_NOT_UNKNOWN";
  }
  Assert(false);
  return NULL;
}

static const char*
_enumToStringCmdType(CmdType value) {
  switch(value) {
    case CMD_UNKNOWN: return "CMD_UNKNOWN";
    case CMD_SELECT: return "CMD_SELECT";
    case CMD_UPDATE: return "CMD_UPDATE";
    case CMD_INSERT: return "CMD_INSERT";
    case CMD_DELETE: return "CMD_DELETE";
    case CMD_MERGE: return "CMD_MERGE";
    case CMD_UTILITY: return "CMD_UTILITY";
    case CMD_NOTHING: return "CMD_NOTHING";
  }
  Assert(false);
  return NULL;
}

static const char*
_enumToStringJoinType(JoinType value) {
  switch(value) {
    case JOIN_INNER: return "JOIN_INNER";
    case JOIN_LEFT: return "JOIN_LEFT";
    case JOIN_FULL: return "JOIN_FULL";
    case JOIN_RIGHT: return "JOIN_RIGHT";
    case JOIN_SEMI: return "JOIN_SEMI";
    case JOIN_ANTI: return "JOIN_ANTI";
    case JOIN_RIGHT_ANTI: return "JOIN_RIGHT_ANTI";
    case JOIN_UNIQUE_OUTER: return "JOIN_UNIQUE_OUTER";
    case JOIN_UNIQUE_INNER: return "JOIN_UNIQUE_INNER";
  }
  Assert(false);
  return NULL;
}

static const char*
_enumToStringAggStrategy(AggStrategy value) {
  switch(value) {
    case AGG_PLAIN: return "AGG_PLAIN";
    case AGG_SORTED: return "AGG_SORTED";
    case AGG_HASHED: return "AGG_HASHED";
    case AGG_MIXED: return "AGG_MIXED";
  }
  Assert(false);
  return NULL;
}

static const char*
_enumToStringAggSplit(AggSplit value) {
  switch(value) {
    case AGGSPLIT_SIMPLE: return "AGGSPLIT_SIMPLE";
    case AGGSPLIT_INITIAL_SERIAL: return "AGGSPLIT_INITIAL_SERIAL";
    case AGGSPLIT_FINAL_DESERIAL: return "AGGSPLIT_FINAL_DESERIAL";
  }
  Assert(false);
  return NULL;
}

static const char*
_enumToStringSetOpCmd(SetOpCmd value) {
  switch(value) {
    case SETOPCMD_INTERSECT: return "SETOPCMD_INTERSECT";
    case SETOPCMD_INTERSECT_ALL: return "SETOPCMD_INTERSECT_ALL";
    case SETOPCMD_EXCEPT: return "SETOPCMD_EXCEPT";
    case SETOPCMD_EXCEPT_ALL: return "SETOPCMD_EXCEPT_ALL";
  }
  Assert(false);
  return NULL;
}

static const char*
_enumToStringSetOpStrategy(SetOpStrategy value) {
  switch(value) {
    case SETOP_SORTED: return "SETOP_SORTED";
    case SETOP_HASHED: return "SETOP_HASHED";
  }
  Assert(false);
  return NULL;
}

static const char*
_enumToStringOnConflictAction(OnConflictAction value) {
  switch(value) {
    case ONCONFLICT_NONE: return "ONCONFLICT_NONE";
    case ONCONFLICT_NOTHING: return "ONCONFLICT_NOTHING";
    case ONCONFLICT_UPDATE: return "ONCONFLICT_UPDATE";
  }
  Assert(false);
  return NULL;
}

static const char*
_enumToStringLimitOption(LimitOption value) {
  switch(value) {
    case LIMIT_OPTION_DEFAULT: return "LIMIT_OPTION_DEFAULT";
    case LIMIT_OPTION_COUNT: return "LIMIT_OPTION_COUNT";
    case LIMIT_OPTION_WITH_TIES: return "LIMIT_OPTION_WITH_TIES";
  }
  Assert(false);
  return NULL;
}

static const char*
_enumToStringLockClauseStrength(LockClauseStrength value) {
  switch(value) {
    case LCS_NONE: return "LCS_NONE";
    case LCS_FORKEYSHARE: return "LCS_FORKEYSHARE";
    case LCS_FORSHARE: return "LCS_FORSHARE";
    case LCS_FORNOKEYUPDATE: return "LCS_FORNOKEYUPDATE";
    case LCS_FORUPDATE: return "LCS_FORUPDATE";
  }
  Assert(false);
  return NULL;
}

static const char*
_enumToStringLockWaitPolicy(LockWaitPolicy value) {
  switch(value) {
    case LockWaitBlock: return "LockWaitBlock";
    case LockWaitSkip: return "LockWaitSkip";
    case LockWaitError: return "LockWaitError";
  }
  Assert(false);
  return NULL;
}

static const char*
_enumToStringLockTupleMode(LockTupleMode value) {
  switch(value) {
    case LockTupleKeyShare: return "LockTupleKeyShare";
    case LockTupleShare: return "LockTupleShare";
    case LockTupleNoKeyExclusive: return "LockTupleNoKeyExclusive";
    case LockTupleExclusive: return "LockTupleExclusive";
  }
  Assert(false);
  return NULL;
}static int
_enumToIntQuerySource(QuerySource value) {
  switch(value) {
    case QSRC_ORIGINAL: return 1;
    case QSRC_PARSER: return 2;
    case QSRC_INSTEAD_RULE: return 3;
    case QSRC_QUAL_INSTEAD_RULE: return 4;
    case QSRC_NON_INSTEAD_RULE: return 5;
  }
  Assert(false);
  return -1;
}

static int
_enumToIntSortByDir(SortByDir value) {
  switch(value) {
    case SORTBY_DEFAULT: return 1;
    case SORTBY_ASC: return 2;
    case SORTBY_DESC: return 3;
    case SORTBY_USING: return 4;
  }
  Assert(false);
  return -1;
}

static int
_enumToIntSortByNulls(SortByNulls value) {
  switch(value) {
    case SORTBY_NULLS_DEFAULT: return 1;
    case SORTBY_NULLS_FIRST: return 2;
    case SORTBY_NULLS_LAST: return 3;
  }
  Assert(false);
  return -1;
}

static int
_enumToIntSetQuantifier(SetQuantifier value) {
  switch(value) {
    case SET_QUANTIFIER_DEFAULT: return 1;
    case SET_QUANTIFIER_ALL: return 2;
    case SET_QUANTIFIER_DISTINCT: return 3;
  }
  Assert(false);
  return -1;
}

static int
_enumToIntA_Expr_Kind(A_Expr_Kind value) {
  switch(value) {
    case AEXPR_OP: return 1;
    case AEXPR_OP_ANY: return 2;
    case AEXPR_OP_ALL: return 3;
    case AEXPR_DISTINCT: return 4;
    case AEXPR_NOT_DISTINCT: return 5;
    case AEXPR_NULLIF: return 6;
    case AEXPR_IN: return 7;
    case AEXPR_LIKE: return 8;
    case AEXPR_ILIKE: return 9;
    case AEXPR_SIMILAR: return 10;
    case AEXPR_BETWEEN: return 11;
    case AEXPR_NOT_BETWEEN: return 12;
    case AEXPR_BETWEEN_SYM: return 13;
    case AEXPR_NOT_BETWEEN_SYM: return 14;
  }
  Assert(false);
  return -1;
}

static int
_enumToIntRoleSpecType(RoleSpecType value) {
  switch(value) {
    case ROLESPEC_CSTRING: return 1;
    case ROLESPEC_CURRENT_ROLE: return 2;
    case ROLESPEC_CURRENT_USER: return 3;
    case ROLESPEC_SESSION_USER: return 4;
    case ROLESPEC_PUBLIC: return 5;
  }
  Assert(false);
  return -1;
}

static int
_enumToIntTableLikeOption(TableLikeOption value) {
  switch(value) {
    case CREATE_TABLE_LIKE_COMMENTS: return 1;
    case CREATE_TABLE_LIKE_COMPRESSION: return 2;
    case CREATE_TABLE_LIKE_CONSTRAINTS: return 3;
    case CREATE_TABLE_LIKE_DEFAULTS: return 4;
    case CREATE_TABLE_LIKE_GENERATED: return 5;
    case CREATE_TABLE_LIKE_IDENTITY: return 6;
    case CREATE_TABLE_LIKE_INDEXES: return 7;
    case CREATE_TABLE_LIKE_STATISTICS: return 8;
    case CREATE_TABLE_LIKE_STORAGE: return 9;
    case CREATE_TABLE_LIKE_ALL: return 10;
  }
  Assert(false);
  return -1;
}

static int
_enumToIntDefElemAction(DefElemAction value) {
  switch(value) {
    case DEFELEM_UNSPEC: return 1;
    case DEFELEM_SET: return 2;
    case DEFELEM_ADD: return 3;
    case DEFELEM_DROP: return 4;
  }
  Assert(false);
  return -1;
}

static int
_enumToIntPartitionStrategy(PartitionStrategy value) {
  switch(value) {
    case PARTITION_STRATEGY_LIST: return 1;
    case PARTITION_STRATEGY_RANGE: return 2;
    case PARTITION_STRATEGY_HASH: return 3;
  }
  Assert(false);
  return -1;
}

static int
_enumToIntPartitionRangeDatumKind(PartitionRangeDatumKind value) {
  switch(value) {
    case PARTITION_RANGE_DATUM_MINVALUE: return 1;
    case PARTITION_RANGE_DATUM_VALUE: return 2;
    case PARTITION_RANGE_DATUM_MAXVALUE: return 3;
  }
  Assert(false);
  return -1;
}

static int
_enumToIntRTEKind(RTEKind value) {
  switch(value) {
    case RTE_RELATION: return 1;
    case RTE_SUBQUERY: return 2;
    case RTE_JOIN: return 3;
    case RTE_FUNCTION: return 4;
    case RTE_TABLEFUNC: return 5;
    case RTE_VALUES: return 6;
    case RTE_CTE: return 7;
    case RTE_NAMEDTUPLESTORE: return 8;
    case RTE_RESULT: return 9;
  }
  Assert(false);
  return -1;
}

static int
_enumToIntWCOKind(WCOKind value) {
  switch(value) {
    case WCO_VIEW_CHECK: return 1;
    case WCO_RLS_INSERT_CHECK: return 2;
    case WCO_RLS_UPDATE_CHECK: return 3;
    case WCO_RLS_CONFLICT_CHECK: return 4;
    case WCO_RLS_MERGE_UPDATE_CHECK: return 5;
    case WCO_RLS_MERGE_DELETE_CHECK: return 6;
  }
  Assert(false);
  return -1;
}

static int
_enumToIntGroupingSetKind(GroupingSetKind value) {
  switch(value) {
    case GROUPING_SET_EMPTY: return 1;
    case GROUPING_SET_SIMPLE: return 2;
    case GROUPING_SET_ROLLUP: return 3;
    case GROUPING_SET_CUBE: return 4;
    case GROUPING_SET_SETS: return 5;
  }
  Assert(false);
  return -1;
}

static int
_enumToIntCTEMaterialize(CTEMaterialize value) {
  switch(value) {
    case CTEMaterializeDefault: return 1;
    case CTEMaterializeAlways: return 2;
    case CTEMaterializeNever: return 3;
  }
  Assert(false);
  return -1;
}

static int
_enumToIntSetOperation(SetOperation value) {
  switch(value) {
    case SETOP_NONE: return 1;
    case SETOP_UNION: return 2;
    case SETOP_INTERSECT: return 3;
    case SETOP_EXCEPT: return 4;
  }
  Assert(false);
  return -1;
}

static int
_enumToIntObjectType(ObjectType value) {
  switch(value) {
    case OBJECT_ACCESS_METHOD: return 1;
    case OBJECT_AGGREGATE: return 2;
    case OBJECT_AMOP: return 3;
    case OBJECT_AMPROC: return 4;
    case OBJECT_ATTRIBUTE: return 5;
    case OBJECT_CAST: return 6;
    case OBJECT_COLUMN: return 7;
    case OBJECT_COLLATION: return 8;
    case OBJECT_CONVERSION: return 9;
    case OBJECT_DATABASE: return 10;
    case OBJECT_DEFAULT: return 11;
    case OBJECT_DEFACL: return 12;
    case OBJECT_DOMAIN: return 13;
    case OBJECT_DOMCONSTRAINT: return 14;
    case OBJECT_EVENT_TRIGGER: return 15;
    case OBJECT_EXTENSION: return 16;
    case OBJECT_FDW: return 17;
    case OBJECT_FOREIGN_SERVER: return 18;
    case OBJECT_FOREIGN_TABLE: return 19;
    case OBJECT_FUNCTION: return 20;
    case OBJECT_INDEX: return 21;
    case OBJECT_LANGUAGE: return 22;
    case OBJECT_LARGEOBJECT: return 23;
    case OBJECT_MATVIEW: return 24;
    case OBJECT_OPCLASS: return 25;
    case OBJECT_OPERATOR: return 26;
    case OBJECT_OPFAMILY: return 27;
    case OBJECT_PARAMETER_ACL: return 28;
    case OBJECT_POLICY: return 29;
    case OBJECT_PROCEDURE: return 30;
    case OBJECT_PUBLICATION: return 31;
    case OBJECT_PUBLICATION_NAMESPACE: return 32;
    case OBJECT_PUBLICATION_REL: return 33;
    case OBJECT_ROLE: return 34;
    case OBJECT_ROUTINE: return 35;
    case OBJECT_RULE: return 36;
    case OBJECT_SCHEMA: return 37;
    case OBJECT_SEQUENCE: return 38;
    case OBJECT_SUBSCRIPTION: return 39;
    case OBJECT_STATISTIC_EXT: return 40;
    case OBJECT_TABCONSTRAINT: return 41;
    case OBJECT_TABLE: return 42;
    case OBJECT_TABLESPACE: return 43;
    case OBJECT_TRANSFORM: return 44;
    case OBJECT_TRIGGER: return 45;
    case OBJECT_TSCONFIGURATION: return 46;
    case OBJECT_TSDICTIONARY: return 47;
    case OBJECT_TSPARSER: return 48;
    case OBJECT_TSTEMPLATE: return 49;
    case OBJECT_TYPE: return 50;
    case OBJECT_USER_MAPPING: return 51;
    case OBJECT_VIEW: return 52;
  }
  Assert(false);
  return -1;
}

static int
_enumToIntDropBehavior(DropBehavior value) {
  switch(value) {
    case DROP_RESTRICT: return 1;
    case DROP_CASCADE: return 2;
  }
  Assert(false);
  return -1;
}

static int
_enumToIntGrantTargetType(GrantTargetType value) {
  switch(value) {
    case ACL_TARGET_OBJECT: return 1;
    case ACL_TARGET_ALL_IN_SCHEMA: return 2;
    case ACL_TARGET_DEFAULTS: return 3;
  }
  Assert(false);
  return -1;
}

static int
_enumToIntVariableSetKind(VariableSetKind value) {
  switch(value) {
    case VAR_SET_VALUE: return 1;
    case VAR_SET_DEFAULT: return 2;
    case VAR_SET_CURRENT: return 3;
    case VAR_SET_MULTI: return 4;
    case VAR_RESET: return 5;
    case VAR_RESET_ALL: return 6;
  }
  Assert(false);
  return -1;
}

static int
_enumToIntConstrType(ConstrType value) {
  switch(value) {
    case CONSTR_NULL: return 1;
    case CONSTR_NOTNULL: return 2;
    case CONSTR_DEFAULT: return 3;
    case CONSTR_IDENTITY: return 4;
    case CONSTR_GENERATED: return 5;
    case CONSTR_CHECK: return 6;
    case CONSTR_PRIMARY: return 7;
    case CONSTR_UNIQUE: return 8;
    case CONSTR_EXCLUSION: return 9;
    case CONSTR_FOREIGN: return 10;
    case CONSTR_ATTR_DEFERRABLE: return 11;
    case CONSTR_ATTR_NOT_DEFERRABLE: return 12;
    case CONSTR_ATTR_DEFERRED: return 13;
    case CONSTR_ATTR_IMMEDIATE: return 14;
  }
  Assert(false);
  return -1;
}

static int
_enumToIntImportForeignSchemaType(ImportForeignSchemaType value) {
  switch(value) {
    case FDW_IMPORT_SCHEMA_ALL: return 1;
    case FDW_IMPORT_SCHEMA_LIMIT_TO: return 2;
    case FDW_IMPORT_SCHEMA_EXCEPT: return 3;
  }
  Assert(false);
  return -1;
}

static int
_enumToIntRoleStmtType(RoleStmtType value) {
  switch(value) {
    case ROLESTMT_ROLE: return 1;
    case ROLESTMT_USER: return 2;
    case ROLESTMT_GROUP: return 3;
  }
  Assert(false);
  return -1;
}

static int
_enumToIntFetchDirection(FetchDirection value) {
  switch(value) {
    case FETCH_FORWARD: return 1;
    case FETCH_BACKWARD: return 2;
    case FETCH_ABSOLUTE: return 3;
    case FETCH_RELATIVE: return 4;
  }
  Assert(false);
  return -1;
}

static int
_enumToIntFunctionParameterMode(FunctionParameterMode value) {
  switch(value) {
    case FUNC_PARAM_IN: return 1;
    case FUNC_PARAM_OUT: return 2;
    case FUNC_PARAM_INOUT: return 3;
    case FUNC_PARAM_VARIADIC: return 4;
    case FUNC_PARAM_TABLE: return 5;
    case FUNC_PARAM_DEFAULT: return 6;
  }
  Assert(false);
  return -1;
}

static int
_enumToIntTransactionStmtKind(TransactionStmtKind value) {
  switch(value) {
    case TRANS_STMT_BEGIN: return 1;
    case TRANS_STMT_START: return 2;
    case TRANS_STMT_COMMIT: return 3;
    case TRANS_STMT_ROLLBACK: return 4;
    case TRANS_STMT_SAVEPOINT: return 5;
    case TRANS_STMT_RELEASE: return 6;
    case TRANS_STMT_ROLLBACK_TO: return 7;
    case TRANS_STMT_PREPARE: return 8;
    case TRANS_STMT_COMMIT_PREPARED: return 9;
    case TRANS_STMT_ROLLBACK_PREPARED: return 10;
  }
  Assert(false);
  return -1;
}

static int
_enumToIntViewCheckOption(ViewCheckOption value) {
  switch(value) {
    case NO_CHECK_OPTION: return 1;
    case LOCAL_CHECK_OPTION: return 2;
    case CASCADED_CHECK_OPTION: return 3;
  }
  Assert(false);
  return -1;
}

static int
_enumToIntDiscardMode(DiscardMode value) {
  switch(value) {
    case DISCARD_ALL: return 1;
    case DISCARD_PLANS: return 2;
    case DISCARD_SEQUENCES: return 3;
    case DISCARD_TEMP: return 4;
  }
  Assert(false);
  return -1;
}

static int
_enumToIntReindexObjectType(ReindexObjectType value) {
  switch(value) {
    case REINDEX_OBJECT_INDEX: return 1;
    case REINDEX_OBJECT_TABLE: return 2;
    case REINDEX_OBJECT_SCHEMA: return 3;
    case REINDEX_OBJECT_SYSTEM: return 4;
    case REINDEX_OBJECT_DATABASE: return 5;
  }
  Assert(false);
  return -1;
}

static int
_enumToIntAlterTSConfigType(AlterTSConfigType value) {
  switch(value) {
    case ALTER_TSCONFIG_ADD_MAPPING: return 1;
    case ALTER_TSCONFIG_ALTER_MAPPING_FOR_TOKEN: return 2;
    case ALTER_TSCONFIG_REPLACE_DICT: return 3;
    case ALTER_TSCONFIG_REPLACE_DICT_FOR_TOKEN: return 4;
    case ALTER_TSCONFIG_DROP_MAPPING: return 5;
  }
  Assert(false);
  return -1;
}

static int
_enumToIntPublicationObjSpecType(PublicationObjSpecType value) {
  switch(value) {
    case PUBLICATIONOBJ_TABLE: return 1;
    case PUBLICATIONOBJ_TABLES_IN_SCHEMA: return 2;
    case PUBLICATIONOBJ_TABLES_IN_CUR_SCHEMA: return 3;
    case PUBLICATIONOBJ_CONTINUATION: return 4;
  }
  Assert(false);
  return -1;
}

static int
_enumToIntAlterPublicationAction(AlterPublicationAction value) {
  switch(value) {
    case AP_AddObjects: return 1;
    case AP_DropObjects: return 2;
    case AP_SetObjects: return 3;
  }
  Assert(false);
  return -1;
}

static int
_enumToIntAlterSubscriptionType(AlterSubscriptionType value) {
  switch(value) {
    case ALTER_SUBSCRIPTION_OPTIONS: return 1;
    case ALTER_SUBSCRIPTION_CONNECTION: return 2;
    case ALTER_SUBSCRIPTION_SET_PUBLICATION: return 3;
    case ALTER_SUBSCRIPTION_ADD_PUBLICATION: return 4;
    case ALTER_SUBSCRIPTION_DROP_PUBLICATION: return 5;
    case ALTER_SUBSCRIPTION_REFRESH: return 6;
    case ALTER_SUBSCRIPTION_ENABLED: return 7;
    case ALTER_SUBSCRIPTION_SKIP: return 8;
  }
  Assert(false);
  return -1;
}

static int
_enumToIntOverridingKind(OverridingKind value) {
  switch(value) {
    case OVERRIDING_NOT_SET: return 1;
    case OVERRIDING_USER_VALUE: return 2;
    case OVERRIDING_SYSTEM_VALUE: return 3;
  }
  Assert(false);
  return -1;
}

static int
_enumToIntOnCommitAction(OnCommitAction value) {
  switch(value) {
    case ONCOMMIT_NOOP: return 1;
    case ONCOMMIT_PRESERVE_ROWS: return 2;
    case ONCOMMIT_DELETE_ROWS: return 3;
    case ONCOMMIT_DROP: return 4;
  }
  Assert(false);
  return -1;
}

static int
_enumToIntParamKind(ParamKind value) {
  switch(value) {
    case PARAM_EXTERN: return 1;
    case PARAM_EXEC: return 2;
    case PARAM_SUBLINK: return 3;
    case PARAM_MULTIEXPR: return 4;
  }
  Assert(false);
  return -1;
}

static int
_enumToIntCoercionContext(CoercionContext value) {
  switch(value) {
    case COERCION_IMPLICIT: return 1;
    case COERCION_ASSIGNMENT: return 2;
    case COERCION_PLPGSQL: return 3;
    case COERCION_EXPLICIT: return 4;
  }
  Assert(false);
  return -1;
}

static int
_enumToIntCoercionForm(CoercionForm value) {
  switch(value) {
    case COERCE_EXPLICIT_CALL: return 1;
    case COERCE_EXPLICIT_CAST: return 2;
    case COERCE_IMPLICIT_CAST: return 3;
    case COERCE_SQL_SYNTAX: return 4;
  }
  Assert(false);
  return -1;
}

static int
_enumToIntBoolExprType(BoolExprType value) {
  switch(value) {
    case AND_EXPR: return 1;
    case OR_EXPR: return 2;
    case NOT_EXPR: return 3;
  }
  Assert(false);
  return -1;
}

static int
_enumToIntSubLinkType(SubLinkType value) {
  switch(value) {
    case EXISTS_SUBLINK: return 1;
    case ALL_SUBLINK: return 2;
    case ANY_SUBLINK: return 3;
    case ROWCOMPARE_SUBLINK: return 4;
    case EXPR_SUBLINK: return 5;
    case MULTIEXPR_SUBLINK: return 6;
    case ARRAY_SUBLINK: return 7;
    case CTE_SUBLINK: return 8;
  }
  Assert(false);
  return -1;
}

static int
_enumToIntRowCompareType(RowCompareType value) {
  switch(value) {
    case ROWCOMPARE_LT: return 1;
    case ROWCOMPARE_LE: return 2;
    case ROWCOMPARE_EQ: return 3;
    case ROWCOMPARE_GE: return 4;
    case ROWCOMPARE_GT: return 5;
    case ROWCOMPARE_NE: return 6;
  }
  Assert(false);
  return -1;
}

static int
_enumToIntMinMaxOp(MinMaxOp value) {
  switch(value) {
    case IS_GREATEST: return 1;
    case IS_LEAST: return 2;
  }
  Assert(false);
  return -1;
}

static int
_enumToIntSQLValueFunctionOp(SQLValueFunctionOp value) {
  switch(value) {
    case SVFOP_CURRENT_DATE: return 1;
    case SVFOP_CURRENT_TIME: return 2;
    case SVFOP_CURRENT_TIME_N: return 3;
    case SVFOP_CURRENT_TIMESTAMP: return 4;
    case SVFOP_CURRENT_TIMESTAMP_N: return 5;
    case SVFOP_LOCALTIME: return 6;
    case SVFOP_LOCALTIME_N: return 7;
    case SVFOP_LOCALTIMESTAMP: return 8;
    case SVFOP_LOCALTIMESTAMP_N: return 9;
    case SVFOP_CURRENT_ROLE: return 10;
    case SVFOP_CURRENT_USER: return 11;
    case SVFOP_USER: return 12;
    case SVFOP_SESSION_USER: return 13;
    case SVFOP_CURRENT_CATALOG: return 14;
    case SVFOP_CURRENT_SCHEMA: return 15;
  }
  Assert(false);
  return -1;
}

static int
_enumToIntXmlExprOp(XmlExprOp value) {
  switch(value) {
    case IS_XMLCONCAT: return 1;
    case IS_XMLELEMENT: return 2;
    case IS_XMLFOREST: return 3;
    case IS_XMLPARSE: return 4;
    case IS_XMLPI: return 5;
    case IS_XMLROOT: return 6;
    case IS_XMLSERIALIZE: return 7;
    case IS_DOCUMENT: return 8;
  }
  Assert(false);
  return -1;
}

static int
_enumToIntXmlOptionType(XmlOptionType value) {
  switch(value) {
    case XMLOPTION_DOCUMENT: return 1;
    case XMLOPTION_CONTENT: return 2;
  }
  Assert(false);
  return -1;
}

static int
_enumToIntJsonEncoding(JsonEncoding value) {
  switch(value) {
    case JS_ENC_DEFAULT: return 1;
    case JS_ENC_UTF8: return 2;
    case JS_ENC_UTF16: return 3;
    case JS_ENC_UTF32: return 4;
  }
  Assert(false);
  return -1;
}

static int
_enumToIntJsonFormatType(JsonFormatType value) {
  switch(value) {
    case JS_FORMAT_DEFAULT: return 1;
    case JS_FORMAT_JSON: return 2;
    case JS_FORMAT_JSONB: return 3;
  }
  Assert(false);
  return -1;
}

static int
_enumToIntJsonValueType(JsonValueType value) {
  switch(value) {
    case JS_TYPE_ANY: return 1;
    case JS_TYPE_OBJECT: return 2;
    case JS_TYPE_ARRAY: return 3;
    case JS_TYPE_SCALAR: return 4;
  }
  Assert(false);
  return -1;
}

static int
_enumToIntNullTestType(NullTestType value) {
  switch(value) {
    case IS_NULL: return 1;
    case IS_NOT_NULL: return 2;
  }
  Assert(false);
  return -1;
}

static int
_enumToIntBoolTestType(BoolTestType value) {
  switch(value) {
    case IS_TRUE: return 1;
    case IS_NOT_TRUE: return 2;
    case IS_FALSE: return 3;
    case IS_NOT_FALSE: return 4;
    case IS_UNKNOWN: return 5;
    case IS_NOT_UNKNOWN: return 6;
  }
  Assert(false);
  return -1;
}

static int
_enumToIntCmdType(CmdType value) {
  switch(value) {
    case CMD_UNKNOWN: return 1;
    case CMD_SELECT: return 2;
    case CMD_UPDATE: return 3;
    case CMD_INSERT: return 4;
    case CMD_DELETE: return 5;
    case CMD_MERGE: return 6;
    case CMD_UTILITY: return 7;
    case CMD_NOTHING: return 8;
  }
  Assert(false);
  return -1;
}

static int
_enumToIntJoinType(JoinType value) {
  switch(value) {
    case JOIN_INNER: return 1;
    case JOIN_LEFT: return 2;
    case JOIN_FULL: return 3;
    case JOIN_RIGHT: return 4;
    case JOIN_SEMI: return 5;
    case JOIN_ANTI: return 6;
    case JOIN_RIGHT_ANTI: return 7;
    case JOIN_UNIQUE_OUTER: return 8;
    case JOIN_UNIQUE_INNER: return 9;
  }
  Assert(false);
  return -1;
}

static int
_enumToIntAggStrategy(AggStrategy value) {
  switch(value) {
    case AGG_PLAIN: return 1;
    case AGG_SORTED: return 2;
    case AGG_HASHED: return 3;
    case AGG_MIXED: return 4;
  }
  Assert(false);
  return -1;
}

static int
_enumToIntAggSplit(AggSplit value) {
  switch(value) {
    case AGGSPLIT_SIMPLE: return 1;
    case AGGSPLIT_INITIAL_SERIAL: return 2;
    case AGGSPLIT_FINAL_DESERIAL: return 3;
  }
  Assert(false);
  return -1;
}

static int
_enumToIntSetOpCmd(SetOpCmd value) {
  switch(value) {
    case SETOPCMD_INTERSECT: return 1;
    case SETOPCMD_INTERSECT_ALL: return 2;
    case SETOPCMD_EXCEPT: return 3;
    case SETOPCMD_EXCEPT_ALL: return 4;
  }
  Assert(false);
  return -1;
}

static int
_enumToIntSetOpStrategy(SetOpStrategy value) {
  switch(value) {
    case SETOP_SORTED: return 1;
    case SETOP_HASHED: return 2;
  }
  Assert(false);
  return -1;
}

static int
_enumToIntOnConflictAction(OnConflictAction value) {
  switch(value) {
    case ONCONFLICT_NONE: return 1;
    case ONCONFLICT_NOTHING: return 2;
    case ONCONFLICT_UPDATE: return 3;
  }
  Assert(false);
  return -1;
}

static int
_enumToIntLimitOption(LimitOption value) {
  switch(value) {
    case LIMIT_OPTION_DEFAULT: return 1;
    case LIMIT_OPTION_COUNT: return 2;
    case LIMIT_OPTION_WITH_TIES: return 3;
  }
  Assert(false);
  return -1;
}

static int
_enumToIntLockClauseStrength(LockClauseStrength value) {
  switch(value) {
    case LCS_NONE: return 1;
    case LCS_FORKEYSHARE: return 2;
    case LCS_FORSHARE: return 3;
    case LCS_FORNOKEYUPDATE: return 4;
    case LCS_FORUPDATE: return 5;
  }
  Assert(false);
  return -1;
}

static int
_enumToIntLockWaitPolicy(LockWaitPolicy value) {
  switch(value) {
    case LockWaitBlock: return 1;
    case LockWaitSkip: return 2;
    case LockWaitError: return 3;
  }
  Assert(false);
  return -1;
}

static int
_enumToIntLockTupleMode(LockTupleMode value) {
  switch(value) {
    case LockTupleKeyShare: return 1;
    case LockTupleShare: return 2;
    case LockTupleNoKeyExclusive: return 3;
    case LockTupleExclusive: return 4;
  }
  Assert(false);
  return -1;
}static QuerySource
_intToEnumQuerySource(int value) {
  switch(value) {
    case 1: return QSRC_ORIGINAL;
    case 2: return QSRC_PARSER;
    case 3: return QSRC_INSTEAD_RULE;
    case 4: return QSRC_QUAL_INSTEAD_RULE;
    case 5: return QSRC_NON_INSTEAD_RULE;
  }
  Assert(false);
  return QSRC_ORIGINAL;
}

static SortByDir
_intToEnumSortByDir(int value) {
  switch(value) {
    case 1: return SORTBY_DEFAULT;
    case 2: return SORTBY_ASC;
    case 3: return SORTBY_DESC;
    case 4: return SORTBY_USING;
  }
  Assert(false);
  return SORTBY_DEFAULT;
}

static SortByNulls
_intToEnumSortByNulls(int value) {
  switch(value) {
    case 1: return SORTBY_NULLS_DEFAULT;
    case 2: return SORTBY_NULLS_FIRST;
    case 3: return SORTBY_NULLS_LAST;
  }
  Assert(false);
  return SORTBY_NULLS_DEFAULT;
}

static SetQuantifier
_intToEnumSetQuantifier(int value) {
  switch(value) {
    case 1: return SET_QUANTIFIER_DEFAULT;
    case 2: return SET_QUANTIFIER_ALL;
    case 3: return SET_QUANTIFIER_DISTINCT;
  }
  Assert(false);
  return SET_QUANTIFIER_DEFAULT;
}

static A_Expr_Kind
_intToEnumA_Expr_Kind(int value) {
  switch(value) {
    case 1: return AEXPR_OP;
    case 2: return AEXPR_OP_ANY;
    case 3: return AEXPR_OP_ALL;
    case 4: return AEXPR_DISTINCT;
    case 5: return AEXPR_NOT_DISTINCT;
    case 6: return AEXPR_NULLIF;
    case 7: return AEXPR_IN;
    case 8: return AEXPR_LIKE;
    case 9: return AEXPR_ILIKE;
    case 10: return AEXPR_SIMILAR;
    case 11: return AEXPR_BETWEEN;
    case 12: return AEXPR_NOT_BETWEEN;
    case 13: return AEXPR_BETWEEN_SYM;
    case 14: return AEXPR_NOT_BETWEEN_SYM;
  }
  Assert(false);
  return AEXPR_OP;
}

static RoleSpecType
_intToEnumRoleSpecType(int value) {
  switch(value) {
    case 1: return ROLESPEC_CSTRING;
    case 2: return ROLESPEC_CURRENT_ROLE;
    case 3: return ROLESPEC_CURRENT_USER;
    case 4: return ROLESPEC_SESSION_USER;
    case 5: return ROLESPEC_PUBLIC;
  }
  Assert(false);
  return ROLESPEC_CSTRING;
}

static TableLikeOption
_intToEnumTableLikeOption(int value) {
  switch(value) {
    case 1: return CREATE_TABLE_LIKE_COMMENTS;
    case 2: return CREATE_TABLE_LIKE_COMPRESSION;
    case 3: return CREATE_TABLE_LIKE_CONSTRAINTS;
    case 4: return CREATE_TABLE_LIKE_DEFAULTS;
    case 5: return CREATE_TABLE_LIKE_GENERATED;
    case 6: return CREATE_TABLE_LIKE_IDENTITY;
    case 7: return CREATE_TABLE_LIKE_INDEXES;
    case 8: return CREATE_TABLE_LIKE_STATISTICS;
    case 9: return CREATE_TABLE_LIKE_STORAGE;
    case 10: return CREATE_TABLE_LIKE_ALL;
  }
  Assert(false);
  return CREATE_TABLE_LIKE_COMMENTS;
}

static DefElemAction
_intToEnumDefElemAction(int value) {
  switch(value) {
    case 1: return DEFELEM_UNSPEC;
    case 2: return DEFELEM_SET;
    case 3: return DEFELEM_ADD;
    case 4: return DEFELEM_DROP;
  }
  Assert(false);
  return DEFELEM_UNSPEC;
}

static PartitionStrategy
_intToEnumPartitionStrategy(int value) {
  switch(value) {
    case 1: return PARTITION_STRATEGY_LIST;
    case 2: return PARTITION_STRATEGY_RANGE;
    case 3: return PARTITION_STRATEGY_HASH;
  }
  Assert(false);
  return PARTITION_STRATEGY_LIST;
}

static PartitionRangeDatumKind
_intToEnumPartitionRangeDatumKind(int value) {
  switch(value) {
    case 1: return PARTITION_RANGE_DATUM_MINVALUE;
    case 2: return PARTITION_RANGE_DATUM_VALUE;
    case 3: return PARTITION_RANGE_DATUM_MAXVALUE;
  }
  Assert(false);
  return PARTITION_RANGE_DATUM_MINVALUE;
}

static RTEKind
_intToEnumRTEKind(int value) {
  switch(value) {
    case 1: return RTE_RELATION;
    case 2: return RTE_SUBQUERY;
    case 3: return RTE_JOIN;
    case 4: return RTE_FUNCTION;
    case 5: return RTE_TABLEFUNC;
    case 6: return RTE_VALUES;
    case 7: return RTE_CTE;
    case 8: return RTE_NAMEDTUPLESTORE;
    case 9: return RTE_RESULT;
  }
  Assert(false);
  return RTE_RELATION;
}

static WCOKind
_intToEnumWCOKind(int value) {
  switch(value) {
    case 1: return WCO_VIEW_CHECK;
    case 2: return WCO_RLS_INSERT_CHECK;
    case 3: return WCO_RLS_UPDATE_CHECK;
    case 4: return WCO_RLS_CONFLICT_CHECK;
    case 5: return WCO_RLS_MERGE_UPDATE_CHECK;
    case 6: return WCO_RLS_MERGE_DELETE_CHECK;
  }
  Assert(false);
  return WCO_VIEW_CHECK;
}

static GroupingSetKind
_intToEnumGroupingSetKind(int value) {
  switch(value) {
    case 1: return GROUPING_SET_EMPTY;
    case 2: return GROUPING_SET_SIMPLE;
    case 3: return GROUPING_SET_ROLLUP;
    case 4: return GROUPING_SET_CUBE;
    case 5: return GROUPING_SET_SETS;
  }
  Assert(false);
  return GROUPING_SET_EMPTY;
}

static CTEMaterialize
_intToEnumCTEMaterialize(int value) {
  switch(value) {
    case 1: return CTEMaterializeDefault;
    case 2: return CTEMaterializeAlways;
    case 3: return CTEMaterializeNever;
  }
  Assert(false);
  return CTEMaterializeDefault;
}

static SetOperation
_intToEnumSetOperation(int value) {
  switch(value) {
    case 1: return SETOP_NONE;
    case 2: return SETOP_UNION;
    case 3: return SETOP_INTERSECT;
    case 4: return SETOP_EXCEPT;
  }
  Assert(false);
  return SETOP_NONE;
}

static ObjectType
_intToEnumObjectType(int value) {
  switch(value) {
    case 1: return OBJECT_ACCESS_METHOD;
    case 2: return OBJECT_AGGREGATE;
    case 3: return OBJECT_AMOP;
    case 4: return OBJECT_AMPROC;
    case 5: return OBJECT_ATTRIBUTE;
    case 6: return OBJECT_CAST;
    case 7: return OBJECT_COLUMN;
    case 8: return OBJECT_COLLATION;
    case 9: return OBJECT_CONVERSION;
    case 10: return OBJECT_DATABASE;
    case 11: return OBJECT_DEFAULT;
    case 12: return OBJECT_DEFACL;
    case 13: return OBJECT_DOMAIN;
    case 14: return OBJECT_DOMCONSTRAINT;
    case 15: return OBJECT_EVENT_TRIGGER;
    case 16: return OBJECT_EXTENSION;
    case 17: return OBJECT_FDW;
    case 18: return OBJECT_FOREIGN_SERVER;
    case 19: return OBJECT_FOREIGN_TABLE;
    case 20: return OBJECT_FUNCTION;
    case 21: return OBJECT_INDEX;
    case 22: return OBJECT_LANGUAGE;
    case 23: return OBJECT_LARGEOBJECT;
    case 24: return OBJECT_MATVIEW;
    case 25: return OBJECT_OPCLASS;
    case 26: return OBJECT_OPERATOR;
    case 27: return OBJECT_OPFAMILY;
    case 28: return OBJECT_PARAMETER_ACL;
    case 29: return OBJECT_POLICY;
    case 30: return OBJECT_PROCEDURE;
    case 31: return OBJECT_PUBLICATION;
    case 32: return OBJECT_PUBLICATION_NAMESPACE;
    case 33: return OBJECT_PUBLICATION_REL;
    case 34: return OBJECT_ROLE;
    case 35: return OBJECT_ROUTINE;
    case 36: return OBJECT_RULE;
    case 37: return OBJECT_SCHEMA;
    case 38: return OBJECT_SEQUENCE;
    case 39: return OBJECT_SUBSCRIPTION;
    case 40: return OBJECT_STATISTIC_EXT;
    case 41: return OBJECT_TABCONSTRAINT;
    case 42: return OBJECT_TABLE;
    case 43: return OBJECT_TABLESPACE;
    case 44: return OBJECT_TRANSFORM;
    case 45: return OBJECT_TRIGGER;
    case 46: return OBJECT_TSCONFIGURATION;
    case 47: return OBJECT_TSDICTIONARY;
    case 48: return OBJECT_TSPARSER;
    case 49: return OBJECT_TSTEMPLATE;
    case 50: return OBJECT_TYPE;
    case 51: return OBJECT_USER_MAPPING;
    case 52: return OBJECT_VIEW;
  }
  Assert(false);
  return OBJECT_ACCESS_METHOD;
}

static DropBehavior
_intToEnumDropBehavior(int value) {
  switch(value) {
    case 1: return DROP_RESTRICT;
    case 2: return DROP_CASCADE;
  }
  Assert(false);
  return DROP_RESTRICT;
}

static GrantTargetType
_intToEnumGrantTargetType(int value) {
  switch(value) {
    case 1: return ACL_TARGET_OBJECT;
    case 2: return ACL_TARGET_ALL_IN_SCHEMA;
    case 3: return ACL_TARGET_DEFAULTS;
  }
  Assert(false);
  return ACL_TARGET_OBJECT;
}

static VariableSetKind
_intToEnumVariableSetKind(int value) {
  switch(value) {
    case 1: return VAR_SET_VALUE;
    case 2: return VAR_SET_DEFAULT;
    case 3: return VAR_SET_CURRENT;
    case 4: return VAR_SET_MULTI;
    case 5: return VAR_RESET;
    case 6: return VAR_RESET_ALL;
  }
  Assert(false);
  return VAR_SET_VALUE;
}

static ConstrType
_intToEnumConstrType(int value) {
  switch(value) {
    case 1: return CONSTR_NULL;
    case 2: return CONSTR_NOTNULL;
    case 3: return CONSTR_DEFAULT;
    case 4: return CONSTR_IDENTITY;
    case 5: return CONSTR_GENERATED;
    case 6: return CONSTR_CHECK;
    case 7: return CONSTR_PRIMARY;
    case 8: return CONSTR_UNIQUE;
    case 9: return CONSTR_EXCLUSION;
    case 10: return CONSTR_FOREIGN;
    case 11: return CONSTR_ATTR_DEFERRABLE;
    case 12: return CONSTR_ATTR_NOT_DEFERRABLE;
    case 13: return CONSTR_ATTR_DEFERRED;
    case 14: return CONSTR_ATTR_IMMEDIATE;
  }
  Assert(false);
  return CONSTR_NULL;
}

static ImportForeignSchemaType
_intToEnumImportForeignSchemaType(int value) {
  switch(value) {
    case 1: return FDW_IMPORT_SCHEMA_ALL;
    case 2: return FDW_IMPORT_SCHEMA_LIMIT_TO;
    case 3: return FDW_IMPORT_SCHEMA_EXCEPT;
  }
  Assert(false);
  return FDW_IMPORT_SCHEMA_ALL;
}

static RoleStmtType
_intToEnumRoleStmtType(int value) {
  switch(value) {
    case 1: return ROLESTMT_ROLE;
    case 2: return ROLESTMT_USER;
    case 3: return ROLESTMT_GROUP;
  }
  Assert(false);
  return ROLESTMT_ROLE;
}

static FetchDirection
_intToEnumFetchDirection(int value) {
  switch(value) {
    case 1: return FETCH_FORWARD;
    case 2: return FETCH_BACKWARD;
    case 3: return FETCH_ABSOLUTE;
    case 4: return FETCH_RELATIVE;
  }
  Assert(false);
  return FETCH_FORWARD;
}

static FunctionParameterMode
_intToEnumFunctionParameterMode(int value) {
  switch(value) {
    case 1: return FUNC_PARAM_IN;
    case 2: return FUNC_PARAM_OUT;
    case 3: return FUNC_PARAM_INOUT;
    case 4: return FUNC_PARAM_VARIADIC;
    case 5: return FUNC_PARAM_TABLE;
    case 6: return FUNC_PARAM_DEFAULT;
  }
  Assert(false);
  return FUNC_PARAM_IN;
}

static TransactionStmtKind
_intToEnumTransactionStmtKind(int value) {
  switch(value) {
    case 1: return TRANS_STMT_BEGIN;
    case 2: return TRANS_STMT_START;
    case 3: return TRANS_STMT_COMMIT;
    case 4: return TRANS_STMT_ROLLBACK;
    case 5: return TRANS_STMT_SAVEPOINT;
    case 6: return TRANS_STMT_RELEASE;
    case 7: return TRANS_STMT_ROLLBACK_TO;
    case 8: return TRANS_STMT_PREPARE;
    case 9: return TRANS_STMT_COMMIT_PREPARED;
    case 10: return TRANS_STMT_ROLLBACK_PREPARED;
  }
  Assert(false);
  return TRANS_STMT_BEGIN;
}

static ViewCheckOption
_intToEnumViewCheckOption(int value) {
  switch(value) {
    case 1: return NO_CHECK_OPTION;
    case 2: return LOCAL_CHECK_OPTION;
    case 3: return CASCADED_CHECK_OPTION;
  }
  Assert(false);
  return NO_CHECK_OPTION;
}

static DiscardMode
_intToEnumDiscardMode(int value) {
  switch(value) {
    case 1: return DISCARD_ALL;
    case 2: return DISCARD_PLANS;
    case 3: return DISCARD_SEQUENCES;
    case 4: return DISCARD_TEMP;
  }
  Assert(false);
  return DISCARD_ALL;
}

static ReindexObjectType
_intToEnumReindexObjectType(int value) {
  switch(value) {
    case 1: return REINDEX_OBJECT_INDEX;
    case 2: return REINDEX_OBJECT_TABLE;
    case 3: return REINDEX_OBJECT_SCHEMA;
    case 4: return REINDEX_OBJECT_SYSTEM;
    case 5: return REINDEX_OBJECT_DATABASE;
  }
  Assert(false);
  return REINDEX_OBJECT_INDEX;
}

static AlterTSConfigType
_intToEnumAlterTSConfigType(int value) {
  switch(value) {
    case 1: return ALTER_TSCONFIG_ADD_MAPPING;
    case 2: return ALTER_TSCONFIG_ALTER_MAPPING_FOR_TOKEN;
    case 3: return ALTER_TSCONFIG_REPLACE_DICT;
    case 4: return ALTER_TSCONFIG_REPLACE_DICT_FOR_TOKEN;
    case 5: return ALTER_TSCONFIG_DROP_MAPPING;
  }
  Assert(false);
  return ALTER_TSCONFIG_ADD_MAPPING;
}

static PublicationObjSpecType
_intToEnumPublicationObjSpecType(int value) {
  switch(value) {
    case 1: return PUBLICATIONOBJ_TABLE;
    case 2: return PUBLICATIONOBJ_TABLES_IN_SCHEMA;
    case 3: return PUBLICATIONOBJ_TABLES_IN_CUR_SCHEMA;
    case 4: return PUBLICATIONOBJ_CONTINUATION;
  }
  Assert(false);
  return PUBLICATIONOBJ_TABLE;
}

static AlterPublicationAction
_intToEnumAlterPublicationAction(int value) {
  switch(value) {
    case 1: return AP_AddObjects;
    case 2: return AP_DropObjects;
    case 3: return AP_SetObjects;
  }
  Assert(false);
  return AP_AddObjects;
}

static AlterSubscriptionType
_intToEnumAlterSubscriptionType(int value) {
  switch(value) {
    case 1: return ALTER_SUBSCRIPTION_OPTIONS;
    case 2: return ALTER_SUBSCRIPTION_CONNECTION;
    case 3: return ALTER_SUBSCRIPTION_SET_PUBLICATION;
    case 4: return ALTER_SUBSCRIPTION_ADD_PUBLICATION;
    case 5: return ALTER_SUBSCRIPTION_DROP_PUBLICATION;
    case 6: return ALTER_SUBSCRIPTION_REFRESH;
    case 7: return ALTER_SUBSCRIPTION_ENABLED;
    case 8: return ALTER_SUBSCRIPTION_SKIP;
  }
  Assert(false);
  return ALTER_SUBSCRIPTION_OPTIONS;
}

static OverridingKind
_intToEnumOverridingKind(int value) {
  switch(value) {
    case 1: return OVERRIDING_NOT_SET;
    case 2: return OVERRIDING_USER_VALUE;
    case 3: return OVERRIDING_SYSTEM_VALUE;
  }
  Assert(false);
  return OVERRIDING_NOT_SET;
}

static OnCommitAction
_intToEnumOnCommitAction(int value) {
  switch(value) {
    case 1: return ONCOMMIT_NOOP;
    case 2: return ONCOMMIT_PRESERVE_ROWS;
    case 3: return ONCOMMIT_DELETE_ROWS;
    case 4: return ONCOMMIT_DROP;
  }
  Assert(false);
  return ONCOMMIT_NOOP;
}

static ParamKind
_intToEnumParamKind(int value) {
  switch(value) {
    case 1: return PARAM_EXTERN;
    case 2: return PARAM_EXEC;
    case 3: return PARAM_SUBLINK;
    case 4: return PARAM_MULTIEXPR;
  }
  Assert(false);
  return PARAM_EXTERN;
}

static CoercionContext
_intToEnumCoercionContext(int value) {
  switch(value) {
    case 1: return COERCION_IMPLICIT;
    case 2: return COERCION_ASSIGNMENT;
    case 3: return COERCION_PLPGSQL;
    case 4: return COERCION_EXPLICIT;
  }
  Assert(false);
  return COERCION_IMPLICIT;
}

static CoercionForm
_intToEnumCoercionForm(int value) {
  switch(value) {
    case 1: return COERCE_EXPLICIT_CALL;
    case 2: return COERCE_EXPLICIT_CAST;
    case 3: return COERCE_IMPLICIT_CAST;
    case 4: return COERCE_SQL_SYNTAX;
  }
  Assert(false);
  return COERCE_EXPLICIT_CALL;
}

static BoolExprType
_intToEnumBoolExprType(int value) {
  switch(value) {
    case 1: return AND_EXPR;
    case 2: return OR_EXPR;
    case 3: return NOT_EXPR;
  }
  Assert(false);
  return AND_EXPR;
}

static SubLinkType
_intToEnumSubLinkType(int value) {
  switch(value) {
    case 1: return EXISTS_SUBLINK;
    case 2: return ALL_SUBLINK;
    case 3: return ANY_SUBLINK;
    case 4: return ROWCOMPARE_SUBLINK;
    case 5: return EXPR_SUBLINK;
    case 6: return MULTIEXPR_SUBLINK;
    case 7: return ARRAY_SUBLINK;
    case 8: return CTE_SUBLINK;
  }
  Assert(false);
  return EXISTS_SUBLINK;
}

static RowCompareType
_intToEnumRowCompareType(int value) {
  switch(value) {
    case 1: return ROWCOMPARE_LT;
    case 2: return ROWCOMPARE_LE;
    case 3: return ROWCOMPARE_EQ;
    case 4: return ROWCOMPARE_GE;
    case 5: return ROWCOMPARE_GT;
    case 6: return ROWCOMPARE_NE;
  }
  Assert(false);
  return ROWCOMPARE_LT;
}

static MinMaxOp
_intToEnumMinMaxOp(int value) {
  switch(value) {
    case 1: return IS_GREATEST;
    case 2: return IS_LEAST;
  }
  Assert(false);
  return IS_GREATEST;
}

static SQLValueFunctionOp
_intToEnumSQLValueFunctionOp(int value) {
  switch(value) {
    case 1: return SVFOP_CURRENT_DATE;
    case 2: return SVFOP_CURRENT_TIME;
    case 3: return SVFOP_CURRENT_TIME_N;
    case 4: return SVFOP_CURRENT_TIMESTAMP;
    case 5: return SVFOP_CURRENT_TIMESTAMP_N;
    case 6: return SVFOP_LOCALTIME;
    case 7: return SVFOP_LOCALTIME_N;
    case 8: return SVFOP_LOCALTIMESTAMP;
    case 9: return SVFOP_LOCALTIMESTAMP_N;
    case 10: return SVFOP_CURRENT_ROLE;
    case 11: return SVFOP_CURRENT_USER;
    case 12: return SVFOP_USER;
    case 13: return SVFOP_SESSION_USER;
    case 14: return SVFOP_CURRENT_CATALOG;
    case 15: return SVFOP_CURRENT_SCHEMA;
  }
  Assert(false);
  return SVFOP_CURRENT_DATE;
}

static XmlExprOp
_intToEnumXmlExprOp(int value) {
  switch(value) {
    case 1: return IS_XMLCONCAT;
    case 2: return IS_XMLELEMENT;
    case 3: return IS_XMLFOREST;
    case 4: return IS_XMLPARSE;
    case 5: return IS_XMLPI;
    case 6: return IS_XMLROOT;
    case 7: return IS_XMLSERIALIZE;
    case 8: return IS_DOCUMENT;
  }
  Assert(false);
  return IS_XMLCONCAT;
}

static XmlOptionType
_intToEnumXmlOptionType(int value) {
  switch(value) {
    case 1: return XMLOPTION_DOCUMENT;
    case 2: return XMLOPTION_CONTENT;
  }
  Assert(false);
  return XMLOPTION_DOCUMENT;
}

static JsonEncoding
_intToEnumJsonEncoding(int value) {
  switch(value) {
    case 1: return JS_ENC_DEFAULT;
    case 2: return JS_ENC_UTF8;
    case 3: return JS_ENC_UTF16;
    case 4: return JS_ENC_UTF32;
  }
  Assert(false);
  return JS_ENC_DEFAULT;
}

static JsonFormatType
_intToEnumJsonFormatType(int value) {
  switch(value) {
    case 1: return JS_FORMAT_DEFAULT;
    case 2: return JS_FORMAT_JSON;
    case 3: return JS_FORMAT_JSONB;
  }
  Assert(false);
  return JS_FORMAT_DEFAULT;
}

static JsonValueType
_intToEnumJsonValueType(int value) {
  switch(value) {
    case 1: return JS_TYPE_ANY;
    case 2: return JS_TYPE_OBJECT;
    case 3: return JS_TYPE_ARRAY;
    case 4: return JS_TYPE_SCALAR;
  }
  Assert(false);
  return JS_TYPE_ANY;
}

static NullTestType
_intToEnumNullTestType(int value) {
  switch(value) {
    case 1: return IS_NULL;
    case 2: return IS_NOT_NULL;
  }
  Assert(false);
  return IS_NULL;
}

static BoolTestType
_intToEnumBoolTestType(int value) {
  switch(value) {
    case 1: return IS_TRUE;
    case 2: return IS_NOT_TRUE;
    case 3: return IS_FALSE;
    case 4: return IS_NOT_FALSE;
    case 5: return IS_UNKNOWN;
    case 6: return IS_NOT_UNKNOWN;
  }
  Assert(false);
  return IS_TRUE;
}

static CmdType
_intToEnumCmdType(int value) {
  switch(value) {
    case 1: return CMD_UNKNOWN;
    case 2: return CMD_SELECT;
    case 3: return CMD_UPDATE;
    case 4: return CMD_INSERT;
    case 5: return CMD_DELETE;
    case 6: return CMD_MERGE;
    case 7: return CMD_UTILITY;
    case 8: return CMD_NOTHING;
  }
  Assert(false);
  return CMD_UNKNOWN;
}

static JoinType
_intToEnumJoinType(int value) {
  switch(value) {
    case 1: return JOIN_INNER;
    case 2: return JOIN_LEFT;
    case 3: return JOIN_FULL;
    case 4: return JOIN_RIGHT;
    case 5: return JOIN_SEMI;
    case 6: return JOIN_ANTI;
    case 7: return JOIN_RIGHT_ANTI;
    case 8: return JOIN_UNIQUE_OUTER;
    case 9: return JOIN_UNIQUE_INNER;
  }
  Assert(false);
  return JOIN_INNER;
}

static AggStrategy
_intToEnumAggStrategy(int value) {
  switch(value) {
    case 1: return AGG_PLAIN;
    case 2: return AGG_SORTED;
    case 3: return AGG_HASHED;
    case 4: return AGG_MIXED;
  }
  Assert(false);
  return AGG_PLAIN;
}

static AggSplit
_intToEnumAggSplit(int value) {
  switch(value) {
    case 1: return AGGSPLIT_SIMPLE;
    case 2: return AGGSPLIT_INITIAL_SERIAL;
    case 3: return AGGSPLIT_FINAL_DESERIAL;
  }
  Assert(false);
  return AGGSPLIT_SIMPLE;
}

static SetOpCmd
_intToEnumSetOpCmd(int value) {
  switch(value) {
    case 1: return SETOPCMD_INTERSECT;
    case 2: return SETOPCMD_INTERSECT_ALL;
    case 3: return SETOPCMD_EXCEPT;
    case 4: return SETOPCMD_EXCEPT_ALL;
  }
  Assert(false);
  return SETOPCMD_INTERSECT;
}

static SetOpStrategy
_intToEnumSetOpStrategy(int value) {
  switch(value) {
    case 1: return SETOP_SORTED;
    case 2: return SETOP_HASHED;
  }
  Assert(false);
  return SETOP_SORTED;
}

static OnConflictAction
_intToEnumOnConflictAction(int value) {
  switch(value) {
    case 1: return ONCONFLICT_NONE;
    case 2: return ONCONFLICT_NOTHING;
    case 3: return ONCONFLICT_UPDATE;
  }
  Assert(false);
  return ONCONFLICT_NONE;
}

static LimitOption
_intToEnumLimitOption(int value) {
  switch(value) {
    case 1: return LIMIT_OPTION_DEFAULT;
    case 2: return LIMIT_OPTION_COUNT;
    case 3: return LIMIT_OPTION_WITH_TIES;
  }
  Assert(false);
  return LIMIT_OPTION_DEFAULT;
}

static LockClauseStrength
_intToEnumLockClauseStrength(int value) {
  switch(value) {
    case 1: return LCS_NONE;
    case 2: return LCS_FORKEYSHARE;
    case 3: return LCS_FORSHARE;
    case 4: return LCS_FORNOKEYUPDATE;
    case 5: return LCS_FORUPDATE;
  }
  Assert(false);
  return LCS_NONE;
}

static LockWaitPolicy
_intToEnumLockWaitPolicy(int value) {
  switch(value) {
    case 1: return LockWaitBlock;
    case 2: return LockWaitSkip;
    case 3: return LockWaitError;
  }
  Assert(false);
  return LockWaitBlock;
}

static LockTupleMode
_intToEnumLockTupleMode(int value) {
  switch(value) {
    case 1: return LockTupleKeyShare;
    case 2: return LockTupleShare;
    case 3: return LockTupleNoKeyExclusive;
    case 4: return LockTupleExclusive;
  }
  Assert(false);
  return LockTupleKeyShare;
}

#define OUT_TYPE(typename, typename_c) StringInfo

#define OUT_NODE(typename, typename_c, typename_underscore, typename_underscore_upcase, typename_cast, fldname) \
  { \
    WRITE_NODE_TYPE(CppAsString(typename)); \
    _out##typename_c(out, (const typename_cast *) obj); \
  }

/* Write the label for the node type */
#define WRITE_NODE_TYPE(nodelabel) \
	appendStringInfoString(out, "\"" nodelabel "\":{")

/* Write an integer field */
#define WRITE_INT_FIELD(outname, outname_json, fldname) \
	if (node->fldname != 0) { \
		appendStringInfo(out, "\"" CppAsString(outname_json) "\":%d,", node->fldname); \
	}

/* Write an unsigned integer field */
#define WRITE_UINT_FIELD(outname, outname_json, fldname) \
	if (node->fldname != 0) { \
		appendStringInfo(out, "\"" CppAsString(outname_json) "\":%u,", node->fldname); \
	}

/* Write an unsigned integer field */
#define WRITE_UINT64_FIELD(outname, outname_json, fldname) \
	if (node->fldname != 0) { \
		appendStringInfo(out, "\"" CppAsString(outname_json) "\":" UINT64_FORMAT ",", node->fldname); \
	}

/* Write a long-integer field */
#define WRITE_LONG_FIELD(outname, outname_json, fldname) \
	if (node->fldname != 0) { \
		appendStringInfo(out, "\"" CppAsString(outname_json) "\":%ld,", node->fldname); \
	}

/* Write a char field (ie, one ascii character) */
#define WRITE_CHAR_FIELD(outname, outname_json, fldname) \
	if (node->fldname != 0) { \
		appendStringInfo(out, "\"" CppAsString(outname_json) "\":\"%c\",", node->fldname); \
	}

/* Write an enumerated-type field */
#define WRITE_ENUM_FIELD(typename, outname, outname_json, fldname) \
	appendStringInfo(out, "\"" CppAsString(outname_json) "\":\"%s\",", \
					 _enumToString##typename(node->fldname));

/* Write a float field */
#define WRITE_FLOAT_FIELD(outname, outname_json, fldname) \
	appendStringInfo(out, "\"" CppAsString(outname_json) "\":%f,", node->fldname)

/* Write a boolean field */
#define WRITE_BOOL_FIELD(outname, outname_json, fldname) \
	if (node->fldname) { \
		appendStringInfo(out, "\"" CppAsString(outname_json) "\":%s,", \
					 	booltostr(node->fldname)); \
	}

/* Write a character-string (possibly NULL) field */
#define WRITE_STRING_FIELD(outname, outname_json, fldname) \
	if (node->fldname != NULL) { \
		appendStringInfo(out, "\"" CppAsString(outname_json) "\":"); \
	 	_outToken(out, node->fldname); \
	 	appendStringInfo(out, ","); \
	}

#define WRITE_LIST_FIELD(outname, outname_json, fldname) \
	if (node->fldname != NULL) { \
		const ListCell *lc; \
		appendStringInfo(out, "\"" CppAsString(outname_json) "\":"); \
		appendStringInfoChar(out, '['); \
		foreach(lc, node->fldname) { \
			if (lfirst(lc) == NULL) \
				appendStringInfoString(out, "{}"); \
			else \
				_outNode(out, lfirst(lc)); \
			if (lnext(node->fldname, lc)) \
				appendStringInfoString(out, ","); \
		} \
		 appendStringInfo(out, "],"); \
    }

#define WRITE_NODE_FIELD(outname, outname_json, fldname) \
	if (true) { \
		 appendStringInfo(out, "\"" CppAsString(outname_json) "\":"); \
	     _outNode(out, &node->fldname); \
		 appendStringInfo(out, ","); \
  	}

#define WRITE_NODE_PTR_FIELD(outname, outname_json, fldname) \
	if (node->fldname != NULL) { \
		 appendStringInfo(out, "\"" CppAsString(outname_json) "\":"); \
		 _outNode(out, node->fldname); \
		 appendStringInfo(out, ","); \
	}

#define WRITE_SPECIFIC_NODE_FIELD(typename, typename_underscore, outname, outname_json, fldname) \
	{ \
    	appendStringInfo(out, "\"" CppAsString(outname_json) "\":{"); \
    	_out##typename(out, &node->fldname); \
		removeTrailingDelimiter(out); \
 		appendStringInfo(out, "},"); \
  	}

#define WRITE_SPECIFIC_NODE_PTR_FIELD(typename, typename_underscore, outname, outname_json, fldname) \
	if (node->fldname != NULL) { \
		 appendStringInfo(out, "\"" CppAsString(outname_json) "\":{"); \
	   	 _out##typename(out, node->fldname); \
		 removeTrailingDelimiter(out); \
 		 appendStringInfo(out, "},"); \
	}

#define WRITE_BITMAPSET_FIELD(outname, outname_json, fldname) \
	if (!bms_is_empty(node->fldname)) \
	{ \
		int x = 0; \
		appendStringInfo(out, "\"" CppAsString(outname_json) "\":["); \
		while ((x = bms_next_member(node->fldname, x)) >= 0) \
			appendStringInfo(out, "%d,", x); \
		removeTrailingDelimiter(out); \
		appendStringInfo(out, "],"); \
	}

static void _outNode(StringInfo out, const void *obj);

static void
_outList(StringInfo out, const List *node)
{
	const ListCell *lc;

	appendStringInfo(out, "\"items\":");
	appendStringInfoChar(out, '[');

	foreach(lc, node)
	{
		if (lfirst(lc) == NULL)
			appendStringInfoString(out, "{}");
		else
			_outNode(out, lfirst(lc));

		if (lnext(node, lc))
			appendStringInfoString(out, ",");
	}

	appendStringInfoChar(out, ']');
	appendStringInfo(out, ",");
}

static void
_outIntList(StringInfo out, const List *node)
{
	const ListCell *lc;

	appendStringInfo(out, "\"items\":");
	appendStringInfoChar(out, '[');

	foreach(lc, node)
	{
		appendStringInfo(out, "%d", lfirst_int(lc));

		if (lnext(node, lc))
			appendStringInfoString(out, ",");
	}

	appendStringInfoChar(out, ']');
	appendStringInfo(out, ",");
}

static void
_outOidList(StringInfo out, const List *node)
{
	const ListCell *lc;

	appendStringInfo(out, "\"items\":");
	appendStringInfoChar(out, '[');

	foreach(lc, node)
	{
		appendStringInfo(out, "%u", lfirst_oid(lc));

		if (lnext(node, lc))
			appendStringInfoString(out, ",");
	}

	appendStringInfoChar(out, ']');
	appendStringInfo(out, ",");
}

static void
_outInteger(StringInfo out, const Integer *node)
{
	/* Don't output anything if the value is the default (0), to match
	 * protobuf's behavior. */
	if (node->ival != 0)
		appendStringInfo(out, "\"ival\":%d", node->ival);
}

static void
_outBoolean(StringInfo out, const Boolean *node)
{
	appendStringInfo(out, "\"boolval\":%s", booltostr(node->boolval));
}

static void
_outFloat(StringInfo out, const Float *node)
{
	appendStringInfo(out, "\"fval\":");
	_outToken(out, node->fval);
}

static void
_outString(StringInfo out, const String *node)
{
	appendStringInfo(out, "\"sval\":");
	_outToken(out, node->sval);
}

static void
_outBitString(StringInfo out, const BitString *node)
{
	appendStringInfo(out, "\"bsval\":");
	_outToken(out, node->bsval);
}

static void
_outAConst(StringInfo out, const A_Const *node)
{
	if (node->isnull) {
		appendStringInfo(out, "\"isnull\":true");
	} else {
		switch (node->val.node.type) {
			case T_Integer:
				appendStringInfoString(out, "\"ival\":{");
				_outInteger(out, &node->val.ival);
				appendStringInfoChar(out, '}');
				break;
			case T_Float:
				appendStringInfoString(out, "\"fval\":{");
				_outFloat(out, &node->val.fval);
				appendStringInfoChar(out, '}');
				break;
			case T_Boolean:
				appendStringInfo(out, "\"boolval\":{%s}", node->val.boolval.boolval ? "\"boolval\":true" : "");
				break;
			case T_String:
				appendStringInfoString(out, "\"sval\":{");
				_outString(out, &node->val.sval);
				appendStringInfoChar(out, '}');
				break;
			case T_BitString:
				appendStringInfoString(out, "\"bsval\":{");
				_outBitString(out, &node->val.bsval);
				appendStringInfoChar(out, '}');
				break;

			// Unreachable, A_Const cannot contain any other nodes.
			default:
				Assert(false);
		}
	}

	appendStringInfo(out, ",\"location\":%d", node->location);
}

static void _outAlias(OUT_TYPE(Alias, Alias) out_node, const Alias *node);
static void _outRangeVar(OUT_TYPE(RangeVar, RangeVar) out_node, const RangeVar *node);
static void _outIntoClause(OUT_TYPE(IntoClause, IntoClause) out_node, const IntoClause *node);
static void _outVar(OUT_TYPE(Var, Var) out_node, const Var *node);
static void _outParam(OUT_TYPE(Param, Param) out_node, const Param *node);
static void _outSubscriptingRef(OUT_TYPE(SubscriptingRef, SubscriptingRef) out_node, const SubscriptingRef *node);
static void _outNamedArgExpr(OUT_TYPE(NamedArgExpr, NamedArgExpr) out_node, const NamedArgExpr *node);
static void _outOpExpr(OUT_TYPE(OpExpr, OpExpr) out_node, const OpExpr *node);
static void _outDistinctExpr(OUT_TYPE(DistinctExpr, DistinctExpr) out_node, const DistinctExpr *node);
static void _outNullIfExpr(OUT_TYPE(NullIfExpr, NullIfExpr) out_node, const NullIfExpr *node);
static void _outScalarArrayOpExpr(OUT_TYPE(ScalarArrayOpExpr, ScalarArrayOpExpr) out_node, const ScalarArrayOpExpr *node);
static void _outBoolExpr(OUT_TYPE(BoolExpr, BoolExpr) out_node, const BoolExpr *node);
static void _outSubLink(OUT_TYPE(SubLink, SubLink) out_node, const SubLink *node);
static void _outSubPlan(OUT_TYPE(SubPlan, SubPlan) out_node, const SubPlan *node);
static void _outAlternativeSubPlan(OUT_TYPE(AlternativeSubPlan, AlternativeSubPlan) out_node, const AlternativeSubPlan *node);
static void _outFieldSelect(OUT_TYPE(FieldSelect, FieldSelect) out_node, const FieldSelect *node);
static void _outFieldStore(OUT_TYPE(FieldStore, FieldStore) out_node, const FieldStore *node);
static void _outRelabelType(OUT_TYPE(RelabelType, RelabelType) out_node, const RelabelType *node);
static void _outCoerceViaIO(OUT_TYPE(CoerceViaIO, CoerceViaIO) out_node, const CoerceViaIO *node);
static void _outArrayCoerceExpr(OUT_TYPE(ArrayCoerceExpr, ArrayCoerceExpr) out_node, const ArrayCoerceExpr *node);
static void _outConvertRowtypeExpr(OUT_TYPE(ConvertRowtypeExpr, ConvertRowtypeExpr) out_node, const ConvertRowtypeExpr *node);
static void _outCollateExpr(OUT_TYPE(CollateExpr, CollateExpr) out_node, const CollateExpr *node);
static void _outCaseExpr(OUT_TYPE(CaseExpr, CaseExpr) out_node, const CaseExpr *node);
static void _outCaseWhen(OUT_TYPE(CaseWhen, CaseWhen) out_node, const CaseWhen *node);
static void _outCaseTestExpr(OUT_TYPE(CaseTestExpr, CaseTestExpr) out_node, const CaseTestExpr *node);
static void _outArrayExpr(OUT_TYPE(ArrayExpr, ArrayExpr) out_node, const ArrayExpr *node);
static void _outRowExpr(OUT_TYPE(RowExpr, RowExpr) out_node, const RowExpr *node);
static void _outNullTest(OUT_TYPE(NullTest, NullTest) out_node, const NullTest *node);
static void _outBooleanTest(OUT_TYPE(BooleanTest, BooleanTest) out_node, const BooleanTest *node);
static void _outCoerceToDomain(OUT_TYPE(CoerceToDomain, CoerceToDomain) out_node, const CoerceToDomain *node);
static void _outCoerceToDomainValue(OUT_TYPE(CoerceToDomainValue, CoerceToDomainValue) out_node, const CoerceToDomainValue *node);
static void _outSetToDefault(OUT_TYPE(SetToDefault, SetToDefault) out_node, const SetToDefault *node);
static void _outCurrentOfExpr(OUT_TYPE(CurrentOfExpr, CurrentOfExpr) out_node, const CurrentOfExpr *node);
static void _outNextValueExpr(OUT_TYPE(NextValueExpr, NextValueExpr) out_node, const NextValueExpr *node);
static void _outInferenceElem(OUT_TYPE(InferenceElem, InferenceElem) out_node, const InferenceElem *node);
static void _outTargetEntry(OUT_TYPE(TargetEntry, TargetEntry) out_node, const TargetEntry *node);
static void _outRangeTblRef(OUT_TYPE(RangeTblRef, RangeTblRef) out_node, const RangeTblRef *node);
static void _outJoinExpr(OUT_TYPE(JoinExpr, JoinExpr) out_node, const JoinExpr *node);
static void _outFromExpr(OUT_TYPE(FromExpr, FromExpr) out_node, const FromExpr *node);
static void _outOnConflictExpr(OUT_TYPE(OnConflictExpr, OnConflictExpr) out_node, const OnConflictExpr *node);
static void _outTypeName(OUT_TYPE(TypeName, TypeName) out_node, const TypeName *node);
static void _outColumnRef(OUT_TYPE(ColumnRef, ColumnRef) out_node, const ColumnRef *node);
static void _outParamRef(OUT_TYPE(ParamRef, ParamRef) out_node, const ParamRef *node);
static void _outAExpr(OUT_TYPE(A_Expr, AExpr) out_node, const A_Expr *node);
static void _outTypeCast(OUT_TYPE(TypeCast, TypeCast) out_node, const TypeCast *node);
static void _outCollateClause(OUT_TYPE(CollateClause, CollateClause) out_node, const CollateClause *node);
static void _outRoleSpec(OUT_TYPE(RoleSpec, RoleSpec) out_node, const RoleSpec *node);
static void _outAStar(OUT_TYPE(A_Star, AStar) out_node, const A_Star *node);
static void _outAIndices(OUT_TYPE(A_Indices, AIndices) out_node, const A_Indices *node);
static void _outAIndirection(OUT_TYPE(A_Indirection, AIndirection) out_node, const A_Indirection *node);
static void _outAArrayExpr(OUT_TYPE(A_ArrayExpr, AArrayExpr) out_node, const A_ArrayExpr *node);
static void _outResTarget(OUT_TYPE(ResTarget, ResTarget) out_node, const ResTarget *node);
static void _outMultiAssignRef(OUT_TYPE(MultiAssignRef, MultiAssignRef) out_node, const MultiAssignRef *node);
static void _outSortBy(OUT_TYPE(SortBy, SortBy) out_node, const SortBy *node);
static void _outWindowDef(OUT_TYPE(WindowDef, WindowDef) out_node, const WindowDef *node);
static void _outRangeSubselect(OUT_TYPE(RangeSubselect, RangeSubselect) out_node, const RangeSubselect *node);
static void _outRangeTableSample(OUT_TYPE(RangeTableSample, RangeTableSample) out_node, const RangeTableSample *node);
static void _outColumnDef(OUT_TYPE(ColumnDef, ColumnDef) out_node, const ColumnDef *node);
static void _outTableLikeClause(OUT_TYPE(TableLikeClause, TableLikeClause) out_node, const TableLikeClause *node);
static void _outIndexElem(OUT_TYPE(IndexElem, IndexElem) out_node, const IndexElem *node);
static void _outDefElem(OUT_TYPE(DefElem, DefElem) out_node, const DefElem *node);
static void _outLockingClause(OUT_TYPE(LockingClause, LockingClause) out_node, const LockingClause *node);
static void _outXmlSerialize(OUT_TYPE(XmlSerialize, XmlSerialize) out_node, const XmlSerialize *node);
static void _outPartitionElem(OUT_TYPE(PartitionElem, PartitionElem) out_node, const PartitionElem *node);
static void _outPartitionSpec(OUT_TYPE(PartitionSpec, PartitionSpec) out_node, const PartitionSpec *node);
static void _outPartitionBoundSpec(OUT_TYPE(PartitionBoundSpec, PartitionBoundSpec) out_node, const PartitionBoundSpec *node);
static void _outPartitionRangeDatum(OUT_TYPE(PartitionRangeDatum, PartitionRangeDatum) out_node, const PartitionRangeDatum *node);
static void _outPartitionCmd(OUT_TYPE(PartitionCmd, PartitionCmd) out_node, const PartitionCmd *node);
static void _outRTEPermissionInfo(OUT_TYPE(RTEPermissionInfo, RTEPermissionInfo) out_node, const RTEPermissionInfo *node);
static void _outTableSampleClause(OUT_TYPE(TableSampleClause, TableSampleClause) out_node, const TableSampleClause *node);
static void _outWithCheckOption(OUT_TYPE(WithCheckOption, WithCheckOption) out_node, const WithCheckOption *node);
static void _outSortGroupClause(OUT_TYPE(SortGroupClause, SortGroupClause) out_node, const SortGroupClause *node);
static void _outGroupingSet(OUT_TYPE(GroupingSet, GroupingSet) out_node, const GroupingSet *node);
static void _outWindowClause(OUT_TYPE(WindowClause, WindowClause) out_node, const WindowClause *node);
static void _outRowMarkClause(OUT_TYPE(RowMarkClause, RowMarkClause) out_node, const RowMarkClause *node);
static void _outWithClause(OUT_TYPE(WithClause, WithClause) out_node, const WithClause *node);
static void _outInferClause(OUT_TYPE(InferClause, InferClause) out_node, const InferClause *node);
static void _outOnConflictClause(OUT_TYPE(OnConflictClause, OnConflictClause) out_node, const OnConflictClause *node);
static void _outCTESearchClause(OUT_TYPE(CTESearchClause, CTESearchClause) out_node, const CTESearchClause *node);
static void _outCTECycleClause(OUT_TYPE(CTECycleClause, CTECycleClause) out_node, const CTECycleClause *node);
static void _outRawStmt(OUT_TYPE(RawStmt, RawStmt) out_node, const RawStmt *node);
static void _outSelectStmt(OUT_TYPE(SelectStmt, SelectStmt) out_node, const SelectStmt *node);
static void _outSetOperationStmt(OUT_TYPE(SetOperationStmt, SetOperationStmt) out_node, const SetOperationStmt *node);
static void _outReturnStmt(OUT_TYPE(ReturnStmt, ReturnStmt) out_node, const ReturnStmt *node);
static void _outPLAssignStmt(OUT_TYPE(PLAssignStmt, PLAssignStmt) out_node, const PLAssignStmt *node);
static void _outCreateSchemaStmt(OUT_TYPE(CreateSchemaStmt, CreateSchemaStmt) out_node, const CreateSchemaStmt *node);
static void _outAlterTableStmt(OUT_TYPE(AlterTableStmt, AlterTableStmt) out_node, const AlterTableStmt *node);
static void _outReplicaIdentityStmt(OUT_TYPE(ReplicaIdentityStmt, ReplicaIdentityStmt) out_node, const ReplicaIdentityStmt *node);
static void _outAlterCollationStmt(OUT_TYPE(AlterCollationStmt, AlterCollationStmt) out_node, const AlterCollationStmt *node);
static void _outAlterDomainStmt(OUT_TYPE(AlterDomainStmt, AlterDomainStmt) out_node, const AlterDomainStmt *node);
static void _outGrantStmt(OUT_TYPE(GrantStmt, GrantStmt) out_node, const GrantStmt *node);
static void _outObjectWithArgs(OUT_TYPE(ObjectWithArgs, ObjectWithArgs) out_node, const ObjectWithArgs *node);
static void _outAccessPriv(OUT_TYPE(AccessPriv, AccessPriv) out_node, const AccessPriv *node);
static void _outGrantRoleStmt(OUT_TYPE(GrantRoleStmt, GrantRoleStmt) out_node, const GrantRoleStmt *node);
static void _outAlterDefaultPrivilegesStmt(OUT_TYPE(AlterDefaultPrivilegesStmt, AlterDefaultPrivilegesStmt) out_node, const AlterDefaultPrivilegesStmt *node);
static void _outCopyStmt(OUT_TYPE(CopyStmt, CopyStmt) out_node, const CopyStmt *node);
static void _outVariableSetStmt(OUT_TYPE(VariableSetStmt, VariableSetStmt) out_node, const VariableSetStmt *node);
static void _outVariableShowStmt(OUT_TYPE(VariableShowStmt, VariableShowStmt) out_node, const VariableShowStmt *node);
static void _outCreateStmt(OUT_TYPE(CreateStmt, CreateStmt) out_node, const CreateStmt *node);
static void _outConstraint(OUT_TYPE(Constraint, Constraint) out_node, const Constraint *node);
static void _outCreateTableSpaceStmt(OUT_TYPE(CreateTableSpaceStmt, CreateTableSpaceStmt) out_node, const CreateTableSpaceStmt *node);
static void _outDropTableSpaceStmt(OUT_TYPE(DropTableSpaceStmt, DropTableSpaceStmt) out_node, const DropTableSpaceStmt *node);
static void _outAlterTableSpaceOptionsStmt(OUT_TYPE(AlterTableSpaceOptionsStmt, AlterTableSpaceOptionsStmt) out_node, const AlterTableSpaceOptionsStmt *node);
static void _outAlterTableMoveAllStmt(OUT_TYPE(AlterTableMoveAllStmt, AlterTableMoveAllStmt) out_node, const AlterTableMoveAllStmt *node);
static void _outCreateExtensionStmt(OUT_TYPE(CreateExtensionStmt, CreateExtensionStmt) out_node, const CreateExtensionStmt *node);
static void _outAlterExtensionStmt(OUT_TYPE(AlterExtensionStmt, AlterExtensionStmt) out_node, const AlterExtensionStmt *node);
static void _outAlterExtensionContentsStmt(OUT_TYPE(AlterExtensionContentsStmt, AlterExtensionContentsStmt) out_node, const AlterExtensionContentsStmt *node);
static void _outCreateFdwStmt(OUT_TYPE(CreateFdwStmt, CreateFdwStmt) out_node, const CreateFdwStmt *node);
static void _outAlterFdwStmt(OUT_TYPE(AlterFdwStmt, AlterFdwStmt) out_node, const AlterFdwStmt *node);
static void _outCreateForeignServerStmt(OUT_TYPE(CreateForeignServerStmt, CreateForeignServerStmt) out_node, const CreateForeignServerStmt *node);
static void _outAlterForeignServerStmt(OUT_TYPE(AlterForeignServerStmt, AlterForeignServerStmt) out_node, const AlterForeignServerStmt *node);
static void _outCreateForeignTableStmt(OUT_TYPE(CreateForeignTableStmt, CreateForeignTableStmt) out_node, const CreateForeignTableStmt *node);
static void _outAlterUserMappingStmt(OUT_TYPE(AlterUserMappingStmt, AlterUserMappingStmt) out_node, const AlterUserMappingStmt *node);
static void _outDropUserMappingStmt(OUT_TYPE(DropUserMappingStmt, DropUserMappingStmt) out_node, const DropUserMappingStmt *node);
static void _outImportForeignSchemaStmt(OUT_TYPE(ImportForeignSchemaStmt, ImportForeignSchemaStmt) out_node, const ImportForeignSchemaStmt *node);
static void _outCreatePolicyStmt(OUT_TYPE(CreatePolicyStmt, CreatePolicyStmt) out_node, const CreatePolicyStmt *node);
static void _outAlterPolicyStmt(OUT_TYPE(AlterPolicyStmt, AlterPolicyStmt) out_node, const AlterPolicyStmt *node);
static void _outCreateAmStmt(OUT_TYPE(CreateAmStmt, CreateAmStmt) out_node, const CreateAmStmt *node);
static void _outCreateTrigStmt(OUT_TYPE(CreateTrigStmt, CreateTrigStmt) out_node, const CreateTrigStmt *node);
static void _outCreateEventTrigStmt(OUT_TYPE(CreateEventTrigStmt, CreateEventTrigStmt) out_node, const CreateEventTrigStmt *node);
static void _outAlterEventTrigStmt(OUT_TYPE(AlterEventTrigStmt, AlterEventTrigStmt) out_node, const AlterEventTrigStmt *node);
static void _outCreatePLangStmt(OUT_TYPE(CreatePLangStmt, CreatePLangStmt) out_node, const CreatePLangStmt *node);
static void _outCreateRoleStmt(OUT_TYPE(CreateRoleStmt, CreateRoleStmt) out_node, const CreateRoleStmt *node);
static void _outAlterRoleStmt(OUT_TYPE(AlterRoleStmt, AlterRoleStmt) out_node, const AlterRoleStmt *node);
static void _outAlterRoleSetStmt(OUT_TYPE(AlterRoleSetStmt, AlterRoleSetStmt) out_node, const AlterRoleSetStmt *node);
static void _outDropRoleStmt(OUT_TYPE(DropRoleStmt, DropRoleStmt) out_node, const DropRoleStmt *node);
static void _outCreateSeqStmt(OUT_TYPE(CreateSeqStmt, CreateSeqStmt) out_node, const CreateSeqStmt *node);
static void _outAlterSeqStmt(OUT_TYPE(AlterSeqStmt, AlterSeqStmt) out_node, const AlterSeqStmt *node);
static void _outDefineStmt(OUT_TYPE(DefineStmt, DefineStmt) out_node, const DefineStmt *node);
static void _outCreateDomainStmt(OUT_TYPE(CreateDomainStmt, CreateDomainStmt) out_node, const CreateDomainStmt *node);
static void _outCreateOpClassStmt(OUT_TYPE(CreateOpClassStmt, CreateOpClassStmt) out_node, const CreateOpClassStmt *node);
static void _outCreateOpClassItem(OUT_TYPE(CreateOpClassItem, CreateOpClassItem) out_node, const CreateOpClassItem *node);
static void _outCreateOpFamilyStmt(OUT_TYPE(CreateOpFamilyStmt, CreateOpFamilyStmt) out_node, const CreateOpFamilyStmt *node);
static void _outAlterOpFamilyStmt(OUT_TYPE(AlterOpFamilyStmt, AlterOpFamilyStmt) out_node, const AlterOpFamilyStmt *node);
static void _outDropStmt(OUT_TYPE(DropStmt, DropStmt) out_node, const DropStmt *node);
static void _outTruncateStmt(OUT_TYPE(TruncateStmt, TruncateStmt) out_node, const TruncateStmt *node);
static void _outCommentStmt(OUT_TYPE(CommentStmt, CommentStmt) out_node, const CommentStmt *node);
static void _outSecLabelStmt(OUT_TYPE(SecLabelStmt, SecLabelStmt) out_node, const SecLabelStmt *node);
static void _outDeclareCursorStmt(OUT_TYPE(DeclareCursorStmt, DeclareCursorStmt) out_node, const DeclareCursorStmt *node);
static void _outClosePortalStmt(OUT_TYPE(ClosePortalStmt, ClosePortalStmt) out_node, const ClosePortalStmt *node);
static void _outFetchStmt(OUT_TYPE(FetchStmt, FetchStmt) out_node, const FetchStmt *node);
static void _outIndexStmt(OUT_TYPE(IndexStmt, IndexStmt) out_node, const IndexStmt *node);
static void _outCreateStatsStmt(OUT_TYPE(CreateStatsStmt, CreateStatsStmt) out_node, const CreateStatsStmt *node);
static void _outStatsElem(OUT_TYPE(StatsElem, StatsElem) out_node, const StatsElem *node);
static void _outDoStmt(OUT_TYPE(DoStmt, DoStmt) out_node, const DoStmt *node);
static void _outInlineCodeBlock(OUT_TYPE(InlineCodeBlock, InlineCodeBlock) out_node, const InlineCodeBlock *node);
static void _outCallContext(OUT_TYPE(CallContext, CallContext) out_node, const CallContext *node);
static void _outRenameStmt(OUT_TYPE(RenameStmt, RenameStmt) out_node, const RenameStmt *node);
static void _outAlterObjectDependsStmt(OUT_TYPE(AlterObjectDependsStmt, AlterObjectDependsStmt) out_node, const AlterObjectDependsStmt *node);
static void _outAlterObjectSchemaStmt(OUT_TYPE(AlterObjectSchemaStmt, AlterObjectSchemaStmt) out_node, const AlterObjectSchemaStmt *node);
static void _outAlterOwnerStmt(OUT_TYPE(AlterOwnerStmt, AlterOwnerStmt) out_node, const AlterOwnerStmt *node);
static void _outAlterOperatorStmt(OUT_TYPE(AlterOperatorStmt, AlterOperatorStmt) out_node, const AlterOperatorStmt *node);
static void _outAlterTypeStmt(OUT_TYPE(AlterTypeStmt, AlterTypeStmt) out_node, const AlterTypeStmt *node);
static void _outRuleStmt(OUT_TYPE(RuleStmt, RuleStmt) out_node, const RuleStmt *node);
static void _outNotifyStmt(OUT_TYPE(NotifyStmt, NotifyStmt) out_node, const NotifyStmt *node);
static void _outListenStmt(OUT_TYPE(ListenStmt, ListenStmt) out_node, const ListenStmt *node);
static void _outUnlistenStmt(OUT_TYPE(UnlistenStmt, UnlistenStmt) out_node, const UnlistenStmt *node);
static void _outCompositeTypeStmt(OUT_TYPE(CompositeTypeStmt, CompositeTypeStmt) out_node, const CompositeTypeStmt *node);
static void _outCreateRangeStmt(OUT_TYPE(CreateRangeStmt, CreateRangeStmt) out_node, const CreateRangeStmt *node);
static void _outAlterEnumStmt(OUT_TYPE(AlterEnumStmt, AlterEnumStmt) out_node, const AlterEnumStmt *node);
static void _outViewStmt(OUT_TYPE(ViewStmt, ViewStmt) out_node, const ViewStmt *node);
static void _outLoadStmt(OUT_TYPE(LoadStmt, LoadStmt) out_node, const LoadStmt *node);
static void _outCreatedbStmt(OUT_TYPE(CreatedbStmt, CreatedbStmt) out_node, const CreatedbStmt *node);
static void _outAlterDatabaseStmt(OUT_TYPE(AlterDatabaseStmt, AlterDatabaseStmt) out_node, const AlterDatabaseStmt *node);
static void _outAlterDatabaseRefreshCollStmt(OUT_TYPE(AlterDatabaseRefreshCollStmt, AlterDatabaseRefreshCollStmt) out_node, const AlterDatabaseRefreshCollStmt *node);
static void _outAlterDatabaseSetStmt(OUT_TYPE(AlterDatabaseSetStmt, AlterDatabaseSetStmt) out_node, const AlterDatabaseSetStmt *node);
static void _outDropdbStmt(OUT_TYPE(DropdbStmt, DropdbStmt) out_node, const DropdbStmt *node);
static void _outAlterSystemStmt(OUT_TYPE(AlterSystemStmt, AlterSystemStmt) out_node, const AlterSystemStmt *node);
static void _outClusterStmt(OUT_TYPE(ClusterStmt, ClusterStmt) out_node, const ClusterStmt *node);
static void _outVacuumStmt(OUT_TYPE(VacuumStmt, VacuumStmt) out_node, const VacuumStmt *node);
static void _outVacuumRelation(OUT_TYPE(VacuumRelation, VacuumRelation) out_node, const VacuumRelation *node);
static void _outExplainStmt(OUT_TYPE(ExplainStmt, ExplainStmt) out_node, const ExplainStmt *node);
static void _outCreateTableAsStmt(OUT_TYPE(CreateTableAsStmt, CreateTableAsStmt) out_node, const CreateTableAsStmt *node);
static void _outRefreshMatViewStmt(OUT_TYPE(RefreshMatViewStmt, RefreshMatViewStmt) out_node, const RefreshMatViewStmt *node);
static void _outCheckPointStmt(OUT_TYPE(CheckPointStmt, CheckPointStmt) out_node, const CheckPointStmt *node);
static void _outDiscardStmt(OUT_TYPE(DiscardStmt, DiscardStmt) out_node, const DiscardStmt *node);
static void _outLockStmt(OUT_TYPE(LockStmt, LockStmt) out_node, const LockStmt *node);
static void _outConstraintsSetStmt(OUT_TYPE(ConstraintsSetStmt, ConstraintsSetStmt) out_node, const ConstraintsSetStmt *node);
static void _outReindexStmt(OUT_TYPE(ReindexStmt, ReindexStmt) out_node, const ReindexStmt *node);
static void _outCreateConversionStmt(OUT_TYPE(CreateConversionStmt, CreateConversionStmt) out_node, const CreateConversionStmt *node);
static void _outCreateCastStmt(OUT_TYPE(CreateCastStmt, CreateCastStmt) out_node, const CreateCastStmt *node);
static void _outCreateTransformStmt(OUT_TYPE(CreateTransformStmt, CreateTransformStmt) out_node, const CreateTransformStmt *node);
static void _outPrepareStmt(OUT_TYPE(PrepareStmt, PrepareStmt) out_node, const PrepareStmt *node);
static void _outExecuteStmt(OUT_TYPE(ExecuteStmt, ExecuteStmt) out_node, const ExecuteStmt *node);
static void _outDropOwnedStmt(OUT_TYPE(DropOwnedStmt, DropOwnedStmt) out_node, const DropOwnedStmt *node);
static void _outReassignOwnedStmt(OUT_TYPE(ReassignOwnedStmt, ReassignOwnedStmt) out_node, const ReassignOwnedStmt *node);
static void _outAlterTSDictionaryStmt(OUT_TYPE(AlterTSDictionaryStmt, AlterTSDictionaryStmt) out_node, const AlterTSDictionaryStmt *node);
static void _outAlterTSConfigurationStmt(OUT_TYPE(AlterTSConfigurationStmt, AlterTSConfigurationStmt) out_node, const AlterTSConfigurationStmt *node);
static void _outPublicationTable(OUT_TYPE(PublicationTable, PublicationTable) out_node, const PublicationTable *node);
static void _outCreatePublicationStmt(OUT_TYPE(CreatePublicationStmt, CreatePublicationStmt) out_node, const CreatePublicationStmt *node);
static void _outAlterPublicationStmt(OUT_TYPE(AlterPublicationStmt, AlterPublicationStmt) out_node, const AlterPublicationStmt *node);
static void _outCreateSubscriptionStmt(OUT_TYPE(CreateSubscriptionStmt, CreateSubscriptionStmt) out_node, const CreateSubscriptionStmt *node);
static void _outAlterSubscriptionStmt(OUT_TYPE(AlterSubscriptionStmt, AlterSubscriptionStmt) out_node, const AlterSubscriptionStmt *node);
static void _outDropSubscriptionStmt(OUT_TYPE(DropSubscriptionStmt, DropSubscriptionStmt) out_node, const DropSubscriptionStmt *node);

static void
_outRawStmt(OUT_TYPE(RawStmt, RawStmt) out, const RawStmt *node)
{
  WRITE_NODE_PTR_FIELD(stmt, stmt, stmt);
  WRITE_INT_FIELD(stmt_location, stmt_location, stmt_location);
  WRITE_INT_FIELD(stmt_len, stmt_len, stmt_len);
}

static void
_outAlias(OUT_TYPE(Alias, Alias) out, const Alias *node)
{
  WRITE_STRING_FIELD(aliasname, aliasname, aliasname);
  WRITE_LIST_FIELD(colnames, colnames, colnames);
}

static void
_outRangeVar(OUT_TYPE(RangeVar, RangeVar) out, const RangeVar *node)
{
  WRITE_STRING_FIELD(catalogname, catalogname, catalogname);
  WRITE_STRING_FIELD(schemaname, schemaname, schemaname);
  WRITE_STRING_FIELD(relname, relname, relname);
  WRITE_BOOL_FIELD(inh, inh, inh);
  WRITE_CHAR_FIELD(relpersistence, relpersistence, relpersistence);
  WRITE_SPECIFIC_NODE_PTR_FIELD(Alias, alias, alias, alias, alias);
  WRITE_INT_FIELD(location, location, location);
}

static void
_outIntoClause(OUT_TYPE(IntoClause, IntoClause) out, const IntoClause *node)
{
  WRITE_SPECIFIC_NODE_PTR_FIELD(RangeVar, range_var, rel, rel, rel);
  WRITE_LIST_FIELD(col_names, colNames, colNames);
  WRITE_STRING_FIELD(access_method, accessMethod, accessMethod);
  WRITE_LIST_FIELD(options, options, options);
  WRITE_STRING_FIELD(table_space_name, tableSpaceName, tableSpaceName);
  WRITE_NODE_PTR_FIELD(view_query, viewQuery, viewQuery);
  WRITE_BOOL_FIELD(skip_data, skipData, skipData);
}

static void
_outVar(OUT_TYPE(Var, Var) out, const Var *node)
{
  WRITE_INT_FIELD(varno, varno, varno);
  WRITE_INT_FIELD(varattno, varattno, varattno);
  WRITE_UINT_FIELD(vartype, vartype, vartype);
  WRITE_INT_FIELD(vartypmod, vartypmod, vartypmod);
  WRITE_UINT_FIELD(varcollid, varcollid, varcollid);
  WRITE_BITMAPSET_FIELD(varnullingrels, varnullingrels, varnullingrels);
  WRITE_UINT_FIELD(varlevelsup, varlevelsup, varlevelsup);
  WRITE_INT_FIELD(location, location, location);
}

static void
_outParam(OUT_TYPE(Param, Param) out, const Param *node)
{
  WRITE_ENUM_FIELD(ParamKind, paramkind, paramkind, paramkind);
  WRITE_INT_FIELD(paramid, paramid, paramid);
  WRITE_UINT_FIELD(paramtype, paramtype, paramtype);
  WRITE_INT_FIELD(paramtypmod, paramtypmod, paramtypmod);
  WRITE_UINT_FIELD(paramcollid, paramcollid, paramcollid);
  WRITE_INT_FIELD(location, location, location);
}

static void
_outSubscriptingRef(OUT_TYPE(SubscriptingRef, SubscriptingRef) out, const SubscriptingRef *node)
{
  WRITE_UINT_FIELD(refcontainertype, refcontainertype, refcontainertype);
  WRITE_UINT_FIELD(refelemtype, refelemtype, refelemtype);
  WRITE_UINT_FIELD(refrestype, refrestype, refrestype);
  WRITE_INT_FIELD(reftypmod, reftypmod, reftypmod);
  WRITE_UINT_FIELD(refcollid, refcollid, refcollid);
  WRITE_LIST_FIELD(refupperindexpr, refupperindexpr, refupperindexpr);
  WRITE_LIST_FIELD(reflowerindexpr, reflowerindexpr, reflowerindexpr);
  WRITE_NODE_PTR_FIELD(refexpr, refexpr, refexpr);
  WRITE_NODE_PTR_FIELD(refassgnexpr, refassgnexpr, refassgnexpr);
}

static void
_outNamedArgExpr(OUT_TYPE(NamedArgExpr, NamedArgExpr) out, const NamedArgExpr *node)
{
  WRITE_NODE_PTR_FIELD(arg, arg, arg);
  WRITE_STRING_FIELD(name, name, name);
  WRITE_INT_FIELD(argnumber, argnumber, argnumber);
  WRITE_INT_FIELD(location, location, location);
}

static void
_outOpExpr(OUT_TYPE(OpExpr, OpExpr) out, const OpExpr *node)
{
  WRITE_UINT_FIELD(opno, opno, opno);
  WRITE_UINT_FIELD(opresulttype, opresulttype, opresulttype);
  WRITE_BOOL_FIELD(opretset, opretset, opretset);
  WRITE_UINT_FIELD(opcollid, opcollid, opcollid);
  WRITE_UINT_FIELD(inputcollid, inputcollid, inputcollid);
  WRITE_LIST_FIELD(args, args, args);
  WRITE_INT_FIELD(location, location, location);
}

static void
_outDistinctExpr(OUT_TYPE(DistinctExpr, DistinctExpr) out, const DistinctExpr *node)
{
  WRITE_UINT_FIELD(opno, opno, opno);
  WRITE_UINT_FIELD(opresulttype, opresulttype, opresulttype);
  WRITE_BOOL_FIELD(opretset, opretset, opretset);
  WRITE_UINT_FIELD(opcollid, opcollid, opcollid);
  WRITE_UINT_FIELD(inputcollid, inputcollid, inputcollid);
  WRITE_LIST_FIELD(args, args, args);
  WRITE_INT_FIELD(location, location, location);
}

static void
_outNullIfExpr(OUT_TYPE(NullIfExpr, NullIfExpr) out, const NullIfExpr *node)
{
  WRITE_UINT_FIELD(opno, opno, opno);
  WRITE_UINT_FIELD(opresulttype, opresulttype, opresulttype);
  WRITE_BOOL_FIELD(opretset, opretset, opretset);
  WRITE_UINT_FIELD(opcollid, opcollid, opcollid);
  WRITE_UINT_FIELD(inputcollid, inputcollid, inputcollid);
  WRITE_LIST_FIELD(args, args, args);
  WRITE_INT_FIELD(location, location, location);
}

static void
_outScalarArrayOpExpr(OUT_TYPE(ScalarArrayOpExpr, ScalarArrayOpExpr) out, const ScalarArrayOpExpr *node)
{
  WRITE_UINT_FIELD(opno, opno, opno);
  WRITE_BOOL_FIELD(use_or, useOr, useOr);
  WRITE_UINT_FIELD(inputcollid, inputcollid, inputcollid);
  WRITE_LIST_FIELD(args, args, args);
  WRITE_INT_FIELD(location, location, location);
}

static void
_outBoolExpr(OUT_TYPE(BoolExpr, BoolExpr) out, const BoolExpr *node)
{
  WRITE_ENUM_FIELD(BoolExprType, boolop, boolop, boolop);
  WRITE_LIST_FIELD(args, args, args);
  WRITE_INT_FIELD(location, location, location);
}

static void
_outSubLink(OUT_TYPE(SubLink, SubLink) out, const SubLink *node)
{
  WRITE_ENUM_FIELD(SubLinkType, sub_link_type, subLinkType, subLinkType);
  WRITE_INT_FIELD(sub_link_id, subLinkId, subLinkId);
  WRITE_NODE_PTR_FIELD(testexpr, testexpr, testexpr);
  WRITE_LIST_FIELD(oper_name, operName, operName);
  WRITE_NODE_PTR_FIELD(subselect, subselect, subselect);
  WRITE_INT_FIELD(location, location, location);
}

static void
_outSubPlan(OUT_TYPE(SubPlan, SubPlan) out, const SubPlan *node)
{
  WRITE_ENUM_FIELD(SubLinkType, sub_link_type, subLinkType, subLinkType);
  WRITE_NODE_PTR_FIELD(testexpr, testexpr, testexpr);
  WRITE_LIST_FIELD(param_ids, paramIds, paramIds);
  WRITE_INT_FIELD(plan_id, plan_id, plan_id);
  WRITE_STRING_FIELD(plan_name, plan_name, plan_name);
  WRITE_UINT_FIELD(first_col_type, firstColType, firstColType);
  WRITE_INT_FIELD(first_col_typmod, firstColTypmod, firstColTypmod);
  WRITE_UINT_FIELD(first_col_collation, firstColCollation, firstColCollation);
  WRITE_BOOL_FIELD(use_hash_table, useHashTable, useHashTable);
  WRITE_BOOL_FIELD(unknown_eq_false, unknownEqFalse, unknownEqFalse);
  WRITE_BOOL_FIELD(parallel_safe, parallel_safe, parallel_safe);
  WRITE_LIST_FIELD(set_param, setParam, setParam);
  WRITE_LIST_FIELD(par_param, parParam, parParam);
  WRITE_LIST_FIELD(args, args, args);
  WRITE_FLOAT_FIELD(startup_cost, startup_cost, startup_cost);
  WRITE_FLOAT_FIELD(per_call_cost, per_call_cost, per_call_cost);
}

static void
_outAlternativeSubPlan(OUT_TYPE(AlternativeSubPlan, AlternativeSubPlan) out, const AlternativeSubPlan *node)
{
  WRITE_LIST_FIELD(subplans, subplans, subplans);
}

static void
_outFieldSelect(OUT_TYPE(FieldSelect, FieldSelect) out, const FieldSelect *node)
{
  WRITE_NODE_PTR_FIELD(arg, arg, arg);
  WRITE_INT_FIELD(fieldnum, fieldnum, fieldnum);
  WRITE_UINT_FIELD(resulttype, resulttype, resulttype);
  WRITE_INT_FIELD(resulttypmod, resulttypmod, resulttypmod);
  WRITE_UINT_FIELD(resultcollid, resultcollid, resultcollid);
}

static void
_outFieldStore(OUT_TYPE(FieldStore, FieldStore) out, const FieldStore *node)
{
  WRITE_NODE_PTR_FIELD(arg, arg, arg);
  WRITE_LIST_FIELD(newvals, newvals, newvals);
  WRITE_LIST_FIELD(fieldnums, fieldnums, fieldnums);
  WRITE_UINT_FIELD(resulttype, resulttype, resulttype);
}

static void
_outRelabelType(OUT_TYPE(RelabelType, RelabelType) out, const RelabelType *node)
{
  WRITE_NODE_PTR_FIELD(arg, arg, arg);
  WRITE_UINT_FIELD(resulttype, resulttype, resulttype);
  WRITE_INT_FIELD(resulttypmod, resulttypmod, resulttypmod);
  WRITE_UINT_FIELD(resultcollid, resultcollid, resultcollid);
  WRITE_INT_FIELD(location, location, location);
}

static void
_outCoerceViaIO(OUT_TYPE(CoerceViaIO, CoerceViaIO) out, const CoerceViaIO *node)
{
  WRITE_NODE_PTR_FIELD(arg, arg, arg);
  WRITE_UINT_FIELD(resulttype, resulttype, resulttype);
  WRITE_UINT_FIELD(resultcollid, resultcollid, resultcollid);
  WRITE_INT_FIELD(location, location, location);
}

static void
_outArrayCoerceExpr(OUT_TYPE(ArrayCoerceExpr, ArrayCoerceExpr) out, const ArrayCoerceExpr *node)
{
  WRITE_NODE_PTR_FIELD(arg, arg, arg);
  WRITE_NODE_PTR_FIELD(elemexpr, elemexpr, elemexpr);
  WRITE_UINT_FIELD(resulttype, resulttype, resulttype);
  WRITE_INT_FIELD(resulttypmod, resulttypmod, resulttypmod);
  WRITE_UINT_FIELD(resultcollid, resultcollid, resultcollid);
  WRITE_INT_FIELD(location, location, location);
}

static void
_outConvertRowtypeExpr(OUT_TYPE(ConvertRowtypeExpr, ConvertRowtypeExpr) out, const ConvertRowtypeExpr *node)
{
  WRITE_NODE_PTR_FIELD(arg, arg, arg);
  WRITE_UINT_FIELD(resulttype, resulttype, resulttype);
  WRITE_INT_FIELD(location, location, location);
}

static void
_outCollateExpr(OUT_TYPE(CollateExpr, CollateExpr) out, const CollateExpr *node)
{
  WRITE_NODE_PTR_FIELD(arg, arg, arg);
  WRITE_UINT_FIELD(coll_oid, collOid, collOid);
  WRITE_INT_FIELD(location, location, location);
}

static void
_outCaseExpr(OUT_TYPE(CaseExpr, CaseExpr) out, const CaseExpr *node)
{
  WRITE_UINT_FIELD(casetype, casetype, casetype);
  WRITE_UINT_FIELD(casecollid, casecollid, casecollid);
  WRITE_NODE_PTR_FIELD(arg, arg, arg);
  WRITE_LIST_FIELD(args, args, args);
  WRITE_NODE_PTR_FIELD(defresult, defresult, defresult);
  WRITE_INT_FIELD(location, location, location);
}

static void
_outCaseWhen(OUT_TYPE(CaseWhen, CaseWhen) out, const CaseWhen *node)
{
  WRITE_NODE_PTR_FIELD(expr, expr, expr);
  WRITE_NODE_PTR_FIELD(result, result, result);
  WRITE_INT_FIELD(location, location, location);
}

static void
_outCaseTestExpr(OUT_TYPE(CaseTestExpr, CaseTestExpr) out, const CaseTestExpr *node)
{
  WRITE_UINT_FIELD(type_id, typeId, typeId);
  WRITE_INT_FIELD(type_mod, typeMod, typeMod);
  WRITE_UINT_FIELD(collation, collation, collation);
}

static void
_outArrayExpr(OUT_TYPE(ArrayExpr, ArrayExpr) out, const ArrayExpr *node)
{
  WRITE_UINT_FIELD(array_typeid, array_typeid, array_typeid);
  WRITE_UINT_FIELD(array_collid, array_collid, array_collid);
  WRITE_UINT_FIELD(element_typeid, element_typeid, element_typeid);
  WRITE_LIST_FIELD(elements, elements, elements);
  WRITE_BOOL_FIELD(multidims, multidims, multidims);
  WRITE_INT_FIELD(location, location, location);
}

static void
_outRowExpr(OUT_TYPE(RowExpr, RowExpr) out, const RowExpr *node)
{
  WRITE_LIST_FIELD(args, args, args);
  WRITE_UINT_FIELD(row_typeid, row_typeid, row_typeid);
  WRITE_LIST_FIELD(colnames, colnames, colnames);
  WRITE_INT_FIELD(location, location, location);
}


static void
_outNullTest(OUT_TYPE(NullTest, NullTest) out, const NullTest *node)
{
  WRITE_NODE_PTR_FIELD(arg, arg, arg);
  WRITE_ENUM_FIELD(NullTestType, nulltesttype, nulltesttype, nulltesttype);
  WRITE_BOOL_FIELD(argisrow, argisrow, argisrow);
  WRITE_INT_FIELD(location, location, location);
}

static void
_outBooleanTest(OUT_TYPE(BooleanTest, BooleanTest) out, const BooleanTest *node)
{
  WRITE_NODE_PTR_FIELD(arg, arg, arg);
  WRITE_ENUM_FIELD(BoolTestType, booltesttype, booltesttype, booltesttype);
  WRITE_INT_FIELD(location, location, location);
}

static void
_outCoerceToDomain(OUT_TYPE(CoerceToDomain, CoerceToDomain) out, const CoerceToDomain *node)
{
  WRITE_NODE_PTR_FIELD(arg, arg, arg);
  WRITE_UINT_FIELD(resulttype, resulttype, resulttype);
  WRITE_INT_FIELD(resulttypmod, resulttypmod, resulttypmod);
  WRITE_UINT_FIELD(resultcollid, resultcollid, resultcollid);
  WRITE_INT_FIELD(location, location, location);
}

static void
_outCoerceToDomainValue(OUT_TYPE(CoerceToDomainValue, CoerceToDomainValue) out, const CoerceToDomainValue *node)
{
  WRITE_UINT_FIELD(type_id, typeId, typeId);
  WRITE_INT_FIELD(type_mod, typeMod, typeMod);
  WRITE_UINT_FIELD(collation, collation, collation);
  WRITE_INT_FIELD(location, location, location);
}

static void
_outSetToDefault(OUT_TYPE(SetToDefault, SetToDefault) out, const SetToDefault *node)
{
  WRITE_UINT_FIELD(type_id, typeId, typeId);
  WRITE_INT_FIELD(type_mod, typeMod, typeMod);
  WRITE_UINT_FIELD(collation, collation, collation);
  WRITE_INT_FIELD(location, location, location);
}

static void
_outCurrentOfExpr(OUT_TYPE(CurrentOfExpr, CurrentOfExpr) out, const CurrentOfExpr *node)
{
  WRITE_UINT_FIELD(cvarno, cvarno, cvarno);
  WRITE_STRING_FIELD(cursor_name, cursor_name, cursor_name);
  WRITE_INT_FIELD(cursor_param, cursor_param, cursor_param);
}

static void
_outNextValueExpr(OUT_TYPE(NextValueExpr, NextValueExpr) out, const NextValueExpr *node)
{
  WRITE_UINT_FIELD(seqid, seqid, seqid);
  WRITE_UINT_FIELD(type_id, typeId, typeId);
}

static void
_outInferenceElem(OUT_TYPE(InferenceElem, InferenceElem) out, const InferenceElem *node)
{
  WRITE_NODE_PTR_FIELD(expr, expr, expr);
  WRITE_UINT_FIELD(infercollid, infercollid, infercollid);
  WRITE_UINT_FIELD(inferopclass, inferopclass, inferopclass);
}

static void
_outTargetEntry(OUT_TYPE(TargetEntry, TargetEntry) out, const TargetEntry *node)
{
  WRITE_NODE_PTR_FIELD(expr, expr, expr);
  WRITE_INT_FIELD(resno, resno, resno);
  WRITE_STRING_FIELD(resname, resname, resname);
  WRITE_UINT_FIELD(ressortgroupref, ressortgroupref, ressortgroupref);
  WRITE_UINT_FIELD(resorigtbl, resorigtbl, resorigtbl);
  WRITE_INT_FIELD(resorigcol, resorigcol, resorigcol);
  WRITE_BOOL_FIELD(resjunk, resjunk, resjunk);
}

static void
_outRangeTblRef(OUT_TYPE(RangeTblRef, RangeTblRef) out, const RangeTblRef *node)
{
  WRITE_INT_FIELD(rtindex, rtindex, rtindex);
}

static void
_outJoinExpr(OUT_TYPE(JoinExpr, JoinExpr) out, const JoinExpr *node)
{
  WRITE_ENUM_FIELD(JoinType, jointype, jointype, jointype);
  WRITE_BOOL_FIELD(is_natural, isNatural, isNatural);
  WRITE_NODE_PTR_FIELD(larg, larg, larg);
  WRITE_NODE_PTR_FIELD(rarg, rarg, rarg);
  WRITE_LIST_FIELD(using_clause, usingClause, usingClause);
  WRITE_SPECIFIC_NODE_PTR_FIELD(Alias, alias, join_using_alias, join_using_alias, join_using_alias);
  WRITE_NODE_PTR_FIELD(quals, quals, quals);
  WRITE_SPECIFIC_NODE_PTR_FIELD(Alias, alias, alias, alias, alias);
  WRITE_INT_FIELD(rtindex, rtindex, rtindex);
}

static void
_outFromExpr(OUT_TYPE(FromExpr, FromExpr) out, const FromExpr *node)
{
  WRITE_LIST_FIELD(fromlist, fromlist, fromlist);
  WRITE_NODE_PTR_FIELD(quals, quals, quals);
}

static void
_outOnConflictExpr(OUT_TYPE(OnConflictExpr, OnConflictExpr) out, const OnConflictExpr *node)
{
  WRITE_LIST_FIELD(arbiter_elems, arbiterElems, arbiterElems);
  WRITE_NODE_PTR_FIELD(arbiter_where, arbiterWhere, arbiterWhere);
  WRITE_UINT_FIELD(constraint, constraint, constraint);
  WRITE_LIST_FIELD(on_conflict_set, onConflictSet, onConflictSet);
  WRITE_NODE_PTR_FIELD(on_conflict_where, onConflictWhere, onConflictWhere);
  WRITE_INT_FIELD(excl_rel_index, exclRelIndex, exclRelIndex);
  WRITE_LIST_FIELD(excl_rel_tlist, exclRelTlist, exclRelTlist);
}

static void
_outTypeName(OUT_TYPE(TypeName, TypeName) out, const TypeName *node)
{
  WRITE_LIST_FIELD(names, names, names);
  WRITE_UINT_FIELD(type_oid, typeOid, typeOid);
  WRITE_BOOL_FIELD(setof, setof, setof);
  WRITE_BOOL_FIELD(pct_type, pct_type, pct_type);
  WRITE_LIST_FIELD(typmods, typmods, typmods);
  WRITE_INT_FIELD(typemod, typemod, typemod);
  WRITE_LIST_FIELD(array_bounds, arrayBounds, arrayBounds);
  WRITE_INT_FIELD(location, location, location);
}

static void
_outColumnRef(OUT_TYPE(ColumnRef, ColumnRef) out, const ColumnRef *node)
{
  WRITE_LIST_FIELD(fields, fields, fields);
  WRITE_INT_FIELD(location, location, location);
}

static void
_outParamRef(OUT_TYPE(ParamRef, ParamRef) out, const ParamRef *node)
{
  WRITE_INT_FIELD(number, number, number);
  WRITE_INT_FIELD(location, location, location);
}

static void
_outAExpr(OUT_TYPE(A_Expr, AExpr) out, const A_Expr *node)
{
  WRITE_ENUM_FIELD(A_Expr_Kind, kind, kind, kind);
  WRITE_LIST_FIELD(name, name, name);
  WRITE_NODE_PTR_FIELD(lexpr, lexpr, lexpr);
  WRITE_NODE_PTR_FIELD(rexpr, rexpr, rexpr);
  WRITE_INT_FIELD(location, location, location);
}

static void
_outTypeCast(OUT_TYPE(TypeCast, TypeCast) out, const TypeCast *node)
{
  WRITE_NODE_PTR_FIELD(arg, arg, arg);
  WRITE_SPECIFIC_NODE_PTR_FIELD(TypeName, type_name, type_name, typeName, typeName);
  WRITE_INT_FIELD(location, location, location);
}

static void
_outCollateClause(OUT_TYPE(CollateClause, CollateClause) out, const CollateClause *node)
{
  WRITE_NODE_PTR_FIELD(arg, arg, arg);
  WRITE_LIST_FIELD(collname, collname, collname);
  WRITE_INT_FIELD(location, location, location);
}

static void
_outRoleSpec(OUT_TYPE(RoleSpec, RoleSpec) out, const RoleSpec *node)
{
  WRITE_STRING_FIELD(rolename, rolename, rolename);
  WRITE_INT_FIELD(location, location, location);
}

static void
_outFuncCall(OUT_TYPE(FuncCall, FuncCall) out, const FuncCall *node)
{
  WRITE_LIST_FIELD(funcname, funcname, funcname);
  WRITE_LIST_FIELD(args, args, args);
  WRITE_LIST_FIELD(agg_order, agg_order, agg_order);
  WRITE_NODE_PTR_FIELD(agg_filter, agg_filter, agg_filter);
  WRITE_SPECIFIC_NODE_PTR_FIELD(WindowDef, window_def, over, over, over);
  WRITE_BOOL_FIELD(agg_within_group, agg_within_group, agg_within_group);
  WRITE_BOOL_FIELD(agg_star, agg_star, agg_star);
  WRITE_BOOL_FIELD(agg_distinct, agg_distinct, agg_distinct);
  WRITE_BOOL_FIELD(func_variadic, func_variadic, func_variadic);
  WRITE_INT_FIELD(location, location, location);
}

static void
_outAStar(OUT_TYPE(A_Star, AStar) out, const A_Star *node)
{
}

static void
_outAIndices(OUT_TYPE(A_Indices, AIndices) out, const A_Indices *node)
{
  WRITE_BOOL_FIELD(is_slice, is_slice, is_slice);
  WRITE_NODE_PTR_FIELD(lidx, lidx, lidx);
  WRITE_NODE_PTR_FIELD(uidx, uidx, uidx);
}

static void
_outAIndirection(OUT_TYPE(A_Indirection, AIndirection) out, const A_Indirection *node)
{
  WRITE_NODE_PTR_FIELD(arg, arg, arg);
  WRITE_LIST_FIELD(indirection, indirection, indirection);
}

static void
_outAArrayExpr(OUT_TYPE(A_ArrayExpr, AArrayExpr) out, const A_ArrayExpr *node)
{
  WRITE_LIST_FIELD(elements, elements, elements);
  WRITE_INT_FIELD(location, location, location);
}

static void
_outResTarget(OUT_TYPE(ResTarget, ResTarget) out, const ResTarget *node)
{
  WRITE_STRING_FIELD(name, name, name);
  WRITE_LIST_FIELD(indirection, indirection, indirection);
  WRITE_NODE_PTR_FIELD(val, val, val);
  WRITE_INT_FIELD(location, location, location);
}

static void
_outMultiAssignRef(OUT_TYPE(MultiAssignRef, MultiAssignRef) out, const MultiAssignRef *node)
{
  WRITE_NODE_PTR_FIELD(source, source, source);
  WRITE_INT_FIELD(colno, colno, colno);
  WRITE_INT_FIELD(ncolumns, ncolumns, ncolumns);
}

static void
_outSortBy(OUT_TYPE(SortBy, SortBy) out, const SortBy *node)
{
  WRITE_NODE_PTR_FIELD(node, node, node);
  WRITE_ENUM_FIELD(SortByDir, sortby_dir, sortby_dir, sortby_dir);
  WRITE_ENUM_FIELD(SortByNulls, sortby_nulls, sortby_nulls, sortby_nulls);
  WRITE_LIST_FIELD(use_op, useOp, useOp);
  WRITE_INT_FIELD(location, location, location);
}

static void
_outWindowDef(OUT_TYPE(WindowDef, WindowDef) out, const WindowDef *node)
{
  WRITE_STRING_FIELD(name, name, name);
  WRITE_STRING_FIELD(refname, refname, refname);
  WRITE_LIST_FIELD(partition_clause, partitionClause, partitionClause);
  WRITE_LIST_FIELD(order_clause, orderClause, orderClause);
  WRITE_INT_FIELD(frame_options, frameOptions, frameOptions);
  WRITE_NODE_PTR_FIELD(start_offset, startOffset, startOffset);
  WRITE_NODE_PTR_FIELD(end_offset, endOffset, endOffset);
  WRITE_INT_FIELD(location, location, location);
}

static void
_outRangeSubselect(OUT_TYPE(RangeSubselect, RangeSubselect) out, const RangeSubselect *node)
{
  WRITE_BOOL_FIELD(lateral, lateral, lateral);
  WRITE_NODE_PTR_FIELD(subquery, subquery, subquery);
  WRITE_SPECIFIC_NODE_PTR_FIELD(Alias, alias, alias, alias, alias);
}

static void
_outRangeFunction(OUT_TYPE(RangeFunction, RangeFunction) out, const RangeFunction *node)
{
  WRITE_BOOL_FIELD(lateral, lateral, lateral);
  WRITE_BOOL_FIELD(ordinality, ordinality, ordinality);
  WRITE_BOOL_FIELD(is_rowsfrom, is_rowsfrom, is_rowsfrom);
  WRITE_LIST_FIELD(functions, functions, functions);
  WRITE_SPECIFIC_NODE_PTR_FIELD(Alias, alias, alias, alias, alias);
  WRITE_LIST_FIELD(coldeflist, coldeflist, coldeflist);
}

static void
_outRangeTableSample(OUT_TYPE(RangeTableSample, RangeTableSample) out, const RangeTableSample *node)
{
  WRITE_NODE_PTR_FIELD(relation, relation, relation);
  WRITE_LIST_FIELD(method, method, method);
  WRITE_LIST_FIELD(args, args, args);
  WRITE_NODE_PTR_FIELD(repeatable, repeatable, repeatable);
  WRITE_INT_FIELD(location, location, location);
}

static void
_outColumnDef(OUT_TYPE(ColumnDef, ColumnDef) out, const ColumnDef *node)
{
  WRITE_STRING_FIELD(colname, colname, colname);
  WRITE_SPECIFIC_NODE_PTR_FIELD(TypeName, type_name, type_name, typeName, typeName);
  WRITE_STRING_FIELD(compression, compression, compression);
  WRITE_INT_FIELD(inhcount, inhcount, inhcount);
  WRITE_BOOL_FIELD(is_local, is_local, is_local);
  WRITE_BOOL_FIELD(is_not_null, is_not_null, is_not_null);
  WRITE_BOOL_FIELD(is_from_type, is_from_type, is_from_type);
  WRITE_CHAR_FIELD(storage, storage, storage);
  WRITE_STRING_FIELD(storage_name, storage_name, storage_name);
  WRITE_NODE_PTR_FIELD(raw_default, raw_default, raw_default);
  WRITE_NODE_PTR_FIELD(cooked_default, cooked_default, cooked_default);
  WRITE_CHAR_FIELD(identity, identity, identity);
  WRITE_SPECIFIC_NODE_PTR_FIELD(RangeVar, range_var, identity_sequence, identitySequence, identitySequence);
  WRITE_CHAR_FIELD(generated, generated, generated);
  WRITE_SPECIFIC_NODE_PTR_FIELD(CollateClause, collate_clause, coll_clause, collClause, collClause);
  WRITE_UINT_FIELD(coll_oid, collOid, collOid);
  WRITE_LIST_FIELD(constraints, constraints, constraints);
  WRITE_LIST_FIELD(fdwoptions, fdwoptions, fdwoptions);
  WRITE_INT_FIELD(location, location, location);
}

static void
_outTableLikeClause(OUT_TYPE(TableLikeClause, TableLikeClause) out, const TableLikeClause *node)
{
  WRITE_SPECIFIC_NODE_PTR_FIELD(RangeVar, range_var, relation, relation, relation);
  WRITE_UINT_FIELD(options, options, options);
  WRITE_UINT_FIELD(relation_oid, relationOid, relationOid);
}

static void
_outIndexElem(OUT_TYPE(IndexElem, IndexElem) out, const IndexElem *node)
{
  WRITE_STRING_FIELD(name, name, name);
  WRITE_NODE_PTR_FIELD(expr, expr, expr);
  WRITE_STRING_FIELD(indexcolname, indexcolname, indexcolname);
  WRITE_LIST_FIELD(collation, collation, collation);
  WRITE_LIST_FIELD(opclass, opclass, opclass);
  WRITE_LIST_FIELD(opclassopts, opclassopts, opclassopts);
  WRITE_ENUM_FIELD(SortByDir, ordering, ordering, ordering);
  WRITE_ENUM_FIELD(SortByNulls, nulls_ordering, nulls_ordering, nulls_ordering);
}

static void
_outDefElem(OUT_TYPE(DefElem, DefElem) out, const DefElem *node)
{
  WRITE_STRING_FIELD(defnamespace, defnamespace, defnamespace);
  WRITE_STRING_FIELD(defname, defname, defname);
  WRITE_NODE_PTR_FIELD(arg, arg, arg);
  WRITE_ENUM_FIELD(DefElemAction, defaction, defaction, defaction);
  WRITE_INT_FIELD(location, location, location);
}

static void
_outLockingClause(OUT_TYPE(LockingClause, LockingClause) out, const LockingClause *node)
{
  WRITE_LIST_FIELD(locked_rels, lockedRels, lockedRels);
  WRITE_ENUM_FIELD(LockClauseStrength, strength, strength, strength);
  WRITE_ENUM_FIELD(LockWaitPolicy, wait_policy, waitPolicy, waitPolicy);
}

static void
_outXmlSerialize(OUT_TYPE(XmlSerialize, XmlSerialize) out, const XmlSerialize *node)
{
  WRITE_ENUM_FIELD(XmlOptionType, xmloption, xmloption, xmloption);
  WRITE_NODE_PTR_FIELD(expr, expr, expr);
  WRITE_SPECIFIC_NODE_PTR_FIELD(TypeName, type_name, type_name, typeName, typeName);
  WRITE_BOOL_FIELD(indent, indent, indent);
  WRITE_INT_FIELD(location, location, location);
}

static void
_outPartitionElem(OUT_TYPE(PartitionElem, PartitionElem) out, const PartitionElem *node)
{
  WRITE_STRING_FIELD(name, name, name);
  WRITE_NODE_PTR_FIELD(expr, expr, expr);
  WRITE_LIST_FIELD(collation, collation, collation);
  WRITE_LIST_FIELD(opclass, opclass, opclass);
  WRITE_INT_FIELD(location, location, location);
}

static void
_outPartitionSpec(OUT_TYPE(PartitionSpec, PartitionSpec) out, const PartitionSpec *node)
{
  WRITE_ENUM_FIELD(PartitionStrategy, strategy, strategy, strategy);
  WRITE_LIST_FIELD(part_params, partParams, partParams);
  WRITE_INT_FIELD(location, location, location);
}

static void
_outPartitionBoundSpec(OUT_TYPE(PartitionBoundSpec, PartitionBoundSpec) out, const PartitionBoundSpec *node)
{
  WRITE_CHAR_FIELD(strategy, strategy, strategy);
  WRITE_BOOL_FIELD(is_default, is_default, is_default);
  WRITE_INT_FIELD(modulus, modulus, modulus);
  WRITE_INT_FIELD(remainder, remainder, remainder);
  WRITE_LIST_FIELD(listdatums, listdatums, listdatums);
  WRITE_LIST_FIELD(lowerdatums, lowerdatums, lowerdatums);
  WRITE_LIST_FIELD(upperdatums, upperdatums, upperdatums);
  WRITE_INT_FIELD(location, location, location);
}

static void
_outPartitionRangeDatum(OUT_TYPE(PartitionRangeDatum, PartitionRangeDatum) out, const PartitionRangeDatum *node)
{
  WRITE_ENUM_FIELD(PartitionRangeDatumKind, kind, kind, kind);
  WRITE_NODE_PTR_FIELD(value, value, value);
  WRITE_INT_FIELD(location, location, location);
}

static void
_outPartitionCmd(OUT_TYPE(PartitionCmd, PartitionCmd) out, const PartitionCmd *node)
{
  WRITE_SPECIFIC_NODE_PTR_FIELD(RangeVar, range_var, name, name, name);
  WRITE_SPECIFIC_NODE_PTR_FIELD(PartitionBoundSpec, partition_bound_spec, bound, bound, bound);
  WRITE_BOOL_FIELD(concurrent, concurrent, concurrent);
}

static void
_outRTEPermissionInfo(OUT_TYPE(RTEPermissionInfo, RTEPermissionInfo) out, const RTEPermissionInfo *node)
{
  WRITE_UINT_FIELD(relid, relid, relid);
  WRITE_BOOL_FIELD(inh, inh, inh);
  WRITE_UINT64_FIELD(required_perms, requiredPerms, requiredPerms);
  WRITE_UINT_FIELD(check_as_user, checkAsUser, checkAsUser);
  WRITE_BITMAPSET_FIELD(selected_cols, selectedCols, selectedCols);
  WRITE_BITMAPSET_FIELD(inserted_cols, insertedCols, insertedCols);
  WRITE_BITMAPSET_FIELD(updated_cols, updatedCols, updatedCols);
}

static void
_outTableSampleClause(OUT_TYPE(TableSampleClause, TableSampleClause) out, const TableSampleClause *node)
{
  WRITE_UINT_FIELD(tsmhandler, tsmhandler, tsmhandler);
  WRITE_LIST_FIELD(args, args, args);
  WRITE_NODE_PTR_FIELD(repeatable, repeatable, repeatable);
}

static void
_outWithCheckOption(OUT_TYPE(WithCheckOption, WithCheckOption) out, const WithCheckOption *node)
{
  WRITE_ENUM_FIELD(WCOKind, kind, kind, kind);
  WRITE_STRING_FIELD(relname, relname, relname);
  WRITE_STRING_FIELD(polname, polname, polname);
  WRITE_NODE_PTR_FIELD(qual, qual, qual);
  WRITE_BOOL_FIELD(cascaded, cascaded, cascaded);
}

static void
_outSortGroupClause(OUT_TYPE(SortGroupClause, SortGroupClause) out, const SortGroupClause *node)
{
  WRITE_UINT_FIELD(tle_sort_group_ref, tleSortGroupRef, tleSortGroupRef);
  WRITE_UINT_FIELD(eqop, eqop, eqop);
  WRITE_UINT_FIELD(sortop, sortop, sortop);
  WRITE_BOOL_FIELD(nulls_first, nulls_first, nulls_first);
  WRITE_BOOL_FIELD(hashable, hashable, hashable);
}

static void
_outGroupingSet(OUT_TYPE(GroupingSet, GroupingSet) out, const GroupingSet *node)
{
  WRITE_ENUM_FIELD(GroupingSetKind, kind, kind, kind);
  WRITE_LIST_FIELD(content, content, content);
  WRITE_INT_FIELD(location, location, location);
}

static void
_outWindowClause(OUT_TYPE(WindowClause, WindowClause) out, const WindowClause *node)
{
  WRITE_STRING_FIELD(name, name, name);
  WRITE_STRING_FIELD(refname, refname, refname);
  WRITE_LIST_FIELD(partition_clause, partitionClause, partitionClause);
  WRITE_LIST_FIELD(order_clause, orderClause, orderClause);
  WRITE_INT_FIELD(frame_options, frameOptions, frameOptions);
  WRITE_NODE_PTR_FIELD(start_offset, startOffset, startOffset);
  WRITE_NODE_PTR_FIELD(end_offset, endOffset, endOffset);
  WRITE_UINT_FIELD(start_in_range_func, startInRangeFunc, startInRangeFunc);
  WRITE_UINT_FIELD(end_in_range_func, endInRangeFunc, endInRangeFunc);
  WRITE_UINT_FIELD(in_range_coll, inRangeColl, inRangeColl);
  WRITE_BOOL_FIELD(in_range_asc, inRangeAsc, inRangeAsc);
  WRITE_BOOL_FIELD(in_range_nulls_first, inRangeNullsFirst, inRangeNullsFirst);
  WRITE_UINT_FIELD(winref, winref, winref);
  WRITE_BOOL_FIELD(copied_order, copiedOrder, copiedOrder);
}

static void
_outRowMarkClause(OUT_TYPE(RowMarkClause, RowMarkClause) out, const RowMarkClause *node)
{
  WRITE_UINT_FIELD(rti, rti, rti);
  WRITE_ENUM_FIELD(LockClauseStrength, strength, strength, strength);
  WRITE_ENUM_FIELD(LockWaitPolicy, wait_policy, waitPolicy, waitPolicy);
  WRITE_BOOL_FIELD(pushed_down, pushedDown, pushedDown);
}

static void
_outWithClause(OUT_TYPE(WithClause, WithClause) out, const WithClause *node)
{
  WRITE_LIST_FIELD(ctes, ctes, ctes);
  WRITE_BOOL_FIELD(recursive, recursive, recursive);
  WRITE_INT_FIELD(location, location, location);
}

static void
_outInferClause(OUT_TYPE(InferClause, InferClause) out, const InferClause *node)
{
  WRITE_LIST_FIELD(index_elems, indexElems, indexElems);
  WRITE_NODE_PTR_FIELD(where_clause, whereClause, whereClause);
  WRITE_STRING_FIELD(conname, conname, conname);
  WRITE_INT_FIELD(location, location, location);
}

static void
_outOnConflictClause(OUT_TYPE(OnConflictClause, OnConflictClause) out, const OnConflictClause *node)
{
  WRITE_SPECIFIC_NODE_PTR_FIELD(InferClause, infer_clause, infer, infer, infer);
  WRITE_LIST_FIELD(target_list, targetList, targetList);
  WRITE_NODE_PTR_FIELD(where_clause, whereClause, whereClause);
  WRITE_INT_FIELD(location, location, location);
}

static void
_outCTESearchClause(OUT_TYPE(CTESearchClause, CTESearchClause) out, const CTESearchClause *node)
{
  WRITE_LIST_FIELD(search_col_list, search_col_list, search_col_list);
  WRITE_BOOL_FIELD(search_breadth_first, search_breadth_first, search_breadth_first);
  WRITE_STRING_FIELD(search_seq_column, search_seq_column, search_seq_column);
  WRITE_INT_FIELD(location, location, location);
}

static void
_outCTECycleClause(OUT_TYPE(CTECycleClause, CTECycleClause) out, const CTECycleClause *node)
{
  WRITE_LIST_FIELD(cycle_col_list, cycle_col_list, cycle_col_list);
  WRITE_STRING_FIELD(cycle_mark_column, cycle_mark_column, cycle_mark_column);
  WRITE_NODE_PTR_FIELD(cycle_mark_value, cycle_mark_value, cycle_mark_value);
  WRITE_NODE_PTR_FIELD(cycle_mark_default, cycle_mark_default, cycle_mark_default);
  WRITE_STRING_FIELD(cycle_path_column, cycle_path_column, cycle_path_column);
  WRITE_INT_FIELD(location, location, location);
  WRITE_UINT_FIELD(cycle_mark_type, cycle_mark_type, cycle_mark_type);
  WRITE_INT_FIELD(cycle_mark_typmod, cycle_mark_typmod, cycle_mark_typmod);
  WRITE_UINT_FIELD(cycle_mark_collation, cycle_mark_collation, cycle_mark_collation);
  WRITE_UINT_FIELD(cycle_mark_neop, cycle_mark_neop, cycle_mark_neop);
}

static void
_outSelectStmt(OUT_TYPE(SelectStmt, SelectStmt) out, const SelectStmt *node)
{
  WRITE_LIST_FIELD(distinct_clause, distinctClause, distinctClause);
  WRITE_SPECIFIC_NODE_PTR_FIELD(IntoClause, into_clause, into_clause, intoClause, intoClause);
  WRITE_LIST_FIELD(target_list, targetList, targetList);
  WRITE_LIST_FIELD(from_clause, fromClause, fromClause);
  WRITE_NODE_PTR_FIELD(where_clause, whereClause, whereClause);
  WRITE_LIST_FIELD(group_clause, groupClause, groupClause);
  WRITE_BOOL_FIELD(group_distinct, groupDistinct, groupDistinct);
  WRITE_NODE_PTR_FIELD(having_clause, havingClause, havingClause);
  WRITE_LIST_FIELD(window_clause, windowClause, windowClause);
  WRITE_LIST_FIELD(values_lists, valuesLists, valuesLists);
  WRITE_LIST_FIELD(sort_clause, sortClause, sortClause);
  WRITE_NODE_PTR_FIELD(limit_offset, limitOffset, limitOffset);
  WRITE_NODE_PTR_FIELD(limit_count, limitCount, limitCount);
  WRITE_ENUM_FIELD(LimitOption, limit_option, limitOption, limitOption);
  WRITE_LIST_FIELD(locking_clause, lockingClause, lockingClause);
  WRITE_SPECIFIC_NODE_PTR_FIELD(WithClause, with_clause, with_clause, withClause, withClause);
  WRITE_ENUM_FIELD(SetOperation, op, op, op);
  WRITE_BOOL_FIELD(all, all, all);
  WRITE_SPECIFIC_NODE_PTR_FIELD(SelectStmt, select_stmt, larg, larg, larg);
  WRITE_SPECIFIC_NODE_PTR_FIELD(SelectStmt, select_stmt, rarg, rarg, rarg);
}

static void
_outSetOperationStmt(OUT_TYPE(SetOperationStmt, SetOperationStmt) out, const SetOperationStmt *node)
{
  WRITE_ENUM_FIELD(SetOperation, op, op, op);
  WRITE_BOOL_FIELD(all, all, all);
  WRITE_NODE_PTR_FIELD(larg, larg, larg);
  WRITE_NODE_PTR_FIELD(rarg, rarg, rarg);
  WRITE_LIST_FIELD(col_types, colTypes, colTypes);
  WRITE_LIST_FIELD(col_typmods, colTypmods, colTypmods);
  WRITE_LIST_FIELD(col_collations, colCollations, colCollations);
  WRITE_LIST_FIELD(group_clauses, groupClauses, groupClauses);
}

static void
_outReturnStmt(OUT_TYPE(ReturnStmt, ReturnStmt) out, const ReturnStmt *node)
{
  WRITE_NODE_PTR_FIELD(returnval, returnval, returnval);
}

static void
_outPLAssignStmt(OUT_TYPE(PLAssignStmt, PLAssignStmt) out, const PLAssignStmt *node)
{
  WRITE_STRING_FIELD(name, name, name);
  WRITE_LIST_FIELD(indirection, indirection, indirection);
  WRITE_INT_FIELD(nnames, nnames, nnames);
  WRITE_SPECIFIC_NODE_PTR_FIELD(SelectStmt, select_stmt, val, val, val);
  WRITE_INT_FIELD(location, location, location);
}

static void
_outCreateSchemaStmt(OUT_TYPE(CreateSchemaStmt, CreateSchemaStmt) out, const CreateSchemaStmt *node)
{
  WRITE_STRING_FIELD(schemaname, schemaname, schemaname);
  WRITE_SPECIFIC_NODE_PTR_FIELD(RoleSpec, role_spec, authrole, authrole, authrole);
  WRITE_LIST_FIELD(schema_elts, schemaElts, schemaElts);
  WRITE_BOOL_FIELD(if_not_exists, if_not_exists, if_not_exists);
}

static void
_outAlterTableStmt(OUT_TYPE(AlterTableStmt, AlterTableStmt) out, const AlterTableStmt *node)
{
  WRITE_SPECIFIC_NODE_PTR_FIELD(RangeVar, range_var, relation, relation, relation);
  WRITE_LIST_FIELD(cmds, cmds, cmds);
  WRITE_ENUM_FIELD(ObjectType, objtype, objtype, objtype);
  WRITE_BOOL_FIELD(missing_ok, missing_ok, missing_ok);
}

static void
_outReplicaIdentityStmt(OUT_TYPE(ReplicaIdentityStmt, ReplicaIdentityStmt) out, const ReplicaIdentityStmt *node)
{
  WRITE_CHAR_FIELD(identity_type, identity_type, identity_type);
  WRITE_STRING_FIELD(name, name, name);
}

static void
_outAlterCollationStmt(OUT_TYPE(AlterCollationStmt, AlterCollationStmt) out, const AlterCollationStmt *node)
{
  WRITE_LIST_FIELD(collname, collname, collname);
}

static void
_outAlterDomainStmt(OUT_TYPE(AlterDomainStmt, AlterDomainStmt) out, const AlterDomainStmt *node)
{
  WRITE_CHAR_FIELD(subtype, subtype, subtype);
  WRITE_LIST_FIELD(type_name, typeName, typeName);
  WRITE_STRING_FIELD(name, name, name);
  WRITE_NODE_PTR_FIELD(def, def, def);
  WRITE_ENUM_FIELD(DropBehavior, behavior, behavior, behavior);
  WRITE_BOOL_FIELD(missing_ok, missing_ok, missing_ok);
}

static void
_outGrantStmt(OUT_TYPE(GrantStmt, GrantStmt) out, const GrantStmt *node)
{
  WRITE_BOOL_FIELD(is_grant, is_grant, is_grant);
  WRITE_ENUM_FIELD(GrantTargetType, targtype, targtype, targtype);
  WRITE_ENUM_FIELD(ObjectType, objtype, objtype, objtype);
  WRITE_LIST_FIELD(objects, objects, objects);
  WRITE_LIST_FIELD(privileges, privileges, privileges);
  WRITE_LIST_FIELD(grantees, grantees, grantees);
  WRITE_BOOL_FIELD(grant_option, grant_option, grant_option);
  WRITE_SPECIFIC_NODE_PTR_FIELD(RoleSpec, role_spec, grantor, grantor, grantor);
  WRITE_ENUM_FIELD(DropBehavior, behavior, behavior, behavior);
}

static void
_outObjectWithArgs(OUT_TYPE(ObjectWithArgs, ObjectWithArgs) out, const ObjectWithArgs *node)
{
  WRITE_LIST_FIELD(objname, objname, objname);
  WRITE_LIST_FIELD(objargs, objargs, objargs);
  WRITE_LIST_FIELD(objfuncargs, objfuncargs, objfuncargs);
  WRITE_BOOL_FIELD(args_unspecified, args_unspecified, args_unspecified);
}

static void
_outAccessPriv(OUT_TYPE(AccessPriv, AccessPriv) out, const AccessPriv *node)
{
  WRITE_STRING_FIELD(priv_name, priv_name, priv_name);
  WRITE_LIST_FIELD(cols, cols, cols);
}

static void
_outGrantRoleStmt(OUT_TYPE(GrantRoleStmt, GrantRoleStmt) out, const GrantRoleStmt *node)
{
  WRITE_LIST_FIELD(granted_roles, granted_roles, granted_roles);
  WRITE_LIST_FIELD(grantee_roles, grantee_roles, grantee_roles);
  WRITE_BOOL_FIELD(is_grant, is_grant, is_grant);
  WRITE_LIST_FIELD(opt, opt, opt);
  WRITE_SPECIFIC_NODE_PTR_FIELD(RoleSpec, role_spec, grantor, grantor, grantor);
  WRITE_ENUM_FIELD(DropBehavior, behavior, behavior, behavior);
}

static void
_outAlterDefaultPrivilegesStmt(OUT_TYPE(AlterDefaultPrivilegesStmt, AlterDefaultPrivilegesStmt) out, const AlterDefaultPrivilegesStmt *node)
{
  WRITE_LIST_FIELD(options, options, options);
  WRITE_SPECIFIC_NODE_PTR_FIELD(GrantStmt, grant_stmt, action, action, action);
}

static void
_outCopyStmt(OUT_TYPE(CopyStmt, CopyStmt) out, const CopyStmt *node)
{
  WRITE_SPECIFIC_NODE_PTR_FIELD(RangeVar, range_var, relation, relation, relation);
  WRITE_NODE_PTR_FIELD(query, query, query);
  WRITE_LIST_FIELD(attlist, attlist, attlist);
  WRITE_BOOL_FIELD(is_from, is_from, is_from);
  WRITE_BOOL_FIELD(is_program, is_program, is_program);
  WRITE_STRING_FIELD(filename, filename, filename);
  WRITE_LIST_FIELD(options, options, options);
  WRITE_NODE_PTR_FIELD(where_clause, whereClause, whereClause);
}

static void
_outVariableSetStmt(OUT_TYPE(VariableSetStmt, VariableSetStmt) out, const VariableSetStmt *node)
{
  WRITE_ENUM_FIELD(VariableSetKind, kind, kind, kind);
  WRITE_STRING_FIELD(name, name, name);
  WRITE_LIST_FIELD(args, args, args);
  WRITE_BOOL_FIELD(is_local, is_local, is_local);
}

static void
_outVariableShowStmt(OUT_TYPE(VariableShowStmt, VariableShowStmt) out, const VariableShowStmt *node)
{
  WRITE_STRING_FIELD(name, name, name);
}

static void
_outCreateStmt(OUT_TYPE(CreateStmt, CreateStmt) out, const CreateStmt *node)
{
  WRITE_SPECIFIC_NODE_PTR_FIELD(RangeVar, range_var, relation, relation, relation);
  WRITE_LIST_FIELD(table_elts, tableElts, tableElts);
  WRITE_LIST_FIELD(inh_relations, inhRelations, inhRelations);
  WRITE_SPECIFIC_NODE_PTR_FIELD(PartitionBoundSpec, partition_bound_spec, partbound, partbound, partbound);
  WRITE_SPECIFIC_NODE_PTR_FIELD(PartitionSpec, partition_spec, partspec, partspec, partspec);
  WRITE_SPECIFIC_NODE_PTR_FIELD(TypeName, type_name, of_typename, ofTypename, ofTypename);
  WRITE_LIST_FIELD(constraints, constraints, constraints);
  WRITE_LIST_FIELD(options, options, options);
  WRITE_STRING_FIELD(tablespacename, tablespacename, tablespacename);
  WRITE_STRING_FIELD(access_method, accessMethod, accessMethod);
  WRITE_BOOL_FIELD(if_not_exists, if_not_exists, if_not_exists);
}

static void
_outConstraint(OUT_TYPE(Constraint, Constraint) out, const Constraint *node)
{
  WRITE_ENUM_FIELD(ConstrType, contype, contype, contype);
  WRITE_STRING_FIELD(conname, conname, conname);
  WRITE_BOOL_FIELD(deferrable, deferrable, deferrable);
  WRITE_BOOL_FIELD(initdeferred, initdeferred, initdeferred);
  WRITE_BOOL_FIELD(skip_validation, skip_validation, skip_validation);
  WRITE_BOOL_FIELD(initially_valid, initially_valid, initially_valid);
  WRITE_BOOL_FIELD(is_no_inherit, is_no_inherit, is_no_inherit);
  WRITE_NODE_PTR_FIELD(raw_expr, raw_expr, raw_expr);
  WRITE_STRING_FIELD(cooked_expr, cooked_expr, cooked_expr);
  WRITE_CHAR_FIELD(generated_when, generated_when, generated_when);
  WRITE_BOOL_FIELD(nulls_not_distinct, nulls_not_distinct, nulls_not_distinct);
  WRITE_LIST_FIELD(keys, keys, keys);
  WRITE_LIST_FIELD(including, including, including);
  WRITE_LIST_FIELD(exclusions, exclusions, exclusions);
  WRITE_LIST_FIELD(options, options, options);
  WRITE_STRING_FIELD(indexname, indexname, indexname);
  WRITE_STRING_FIELD(indexspace, indexspace, indexspace);
  WRITE_BOOL_FIELD(reset_default_tblspc, reset_default_tblspc, reset_default_tblspc);
  WRITE_STRING_FIELD(access_method, access_method, access_method);
  WRITE_NODE_PTR_FIELD(where_clause, where_clause, where_clause);
  WRITE_SPECIFIC_NODE_PTR_FIELD(RangeVar, range_var, pktable, pktable, pktable);
  WRITE_LIST_FIELD(fk_attrs, fk_attrs, fk_attrs);
  WRITE_LIST_FIELD(pk_attrs, pk_attrs, pk_attrs);
  WRITE_CHAR_FIELD(fk_matchtype, fk_matchtype, fk_matchtype);
  WRITE_CHAR_FIELD(fk_upd_action, fk_upd_action, fk_upd_action);
  WRITE_CHAR_FIELD(fk_del_action, fk_del_action, fk_del_action);
  WRITE_LIST_FIELD(fk_del_set_cols, fk_del_set_cols, fk_del_set_cols);
  WRITE_LIST_FIELD(old_conpfeqop, old_conpfeqop, old_conpfeqop);
  WRITE_UINT_FIELD(old_pktable_oid, old_pktable_oid, old_pktable_oid);
  WRITE_INT_FIELD(location, location, location);
}

static void
_outCreateTableSpaceStmt(OUT_TYPE(CreateTableSpaceStmt, CreateTableSpaceStmt) out, const CreateTableSpaceStmt *node)
{
  WRITE_STRING_FIELD(tablespacename, tablespacename, tablespacename);
  WRITE_SPECIFIC_NODE_PTR_FIELD(RoleSpec, role_spec, owner, owner, owner);
  WRITE_STRING_FIELD(location, location, location);
  WRITE_LIST_FIELD(options, options, options);
}

static void
_outDropTableSpaceStmt(OUT_TYPE(DropTableSpaceStmt, DropTableSpaceStmt) out, const DropTableSpaceStmt *node)
{
  WRITE_STRING_FIELD(tablespacename, tablespacename, tablespacename);
  WRITE_BOOL_FIELD(missing_ok, missing_ok, missing_ok);
}

static void
_outAlterTableSpaceOptionsStmt(OUT_TYPE(AlterTableSpaceOptionsStmt, AlterTableSpaceOptionsStmt) out, const AlterTableSpaceOptionsStmt *node)
{
  WRITE_STRING_FIELD(tablespacename, tablespacename, tablespacename);
  WRITE_LIST_FIELD(options, options, options);
  WRITE_BOOL_FIELD(is_reset, isReset, isReset);
}

static void
_outAlterTableMoveAllStmt(OUT_TYPE(AlterTableMoveAllStmt, AlterTableMoveAllStmt) out, const AlterTableMoveAllStmt *node)
{
  WRITE_STRING_FIELD(orig_tablespacename, orig_tablespacename, orig_tablespacename);
  WRITE_ENUM_FIELD(ObjectType, objtype, objtype, objtype);
  WRITE_LIST_FIELD(roles, roles, roles);
  WRITE_STRING_FIELD(new_tablespacename, new_tablespacename, new_tablespacename);
  WRITE_BOOL_FIELD(nowait, nowait, nowait);
}

static void
_outCreateExtensionStmt(OUT_TYPE(CreateExtensionStmt, CreateExtensionStmt) out, const CreateExtensionStmt *node)
{
  WRITE_STRING_FIELD(extname, extname, extname);
  WRITE_BOOL_FIELD(if_not_exists, if_not_exists, if_not_exists);
  WRITE_LIST_FIELD(options, options, options);
}

static void
_outAlterExtensionStmt(OUT_TYPE(AlterExtensionStmt, AlterExtensionStmt) out, const AlterExtensionStmt *node)
{
  WRITE_STRING_FIELD(extname, extname, extname);
  WRITE_LIST_FIELD(options, options, options);
}

static void
_outAlterExtensionContentsStmt(OUT_TYPE(AlterExtensionContentsStmt, AlterExtensionContentsStmt) out, const AlterExtensionContentsStmt *node)
{
  WRITE_STRING_FIELD(extname, extname, extname);
  WRITE_INT_FIELD(action, action, action);
  WRITE_ENUM_FIELD(ObjectType, objtype, objtype, objtype);
  WRITE_NODE_PTR_FIELD(object, object, object);
}

static void
_outCreateFdwStmt(OUT_TYPE(CreateFdwStmt, CreateFdwStmt) out, const CreateFdwStmt *node)
{
  WRITE_STRING_FIELD(fdwname, fdwname, fdwname);
  WRITE_LIST_FIELD(func_options, func_options, func_options);
  WRITE_LIST_FIELD(options, options, options);
}

static void
_outAlterFdwStmt(OUT_TYPE(AlterFdwStmt, AlterFdwStmt) out, const AlterFdwStmt *node)
{
  WRITE_STRING_FIELD(fdwname, fdwname, fdwname);
  WRITE_LIST_FIELD(func_options, func_options, func_options);
  WRITE_LIST_FIELD(options, options, options);
}

static void
_outCreateForeignServerStmt(OUT_TYPE(CreateForeignServerStmt, CreateForeignServerStmt) out, const CreateForeignServerStmt *node)
{
  WRITE_STRING_FIELD(servername, servername, servername);
  WRITE_STRING_FIELD(servertype, servertype, servertype);
  WRITE_STRING_FIELD(version, version, version);
  WRITE_STRING_FIELD(fdwname, fdwname, fdwname);
  WRITE_BOOL_FIELD(if_not_exists, if_not_exists, if_not_exists);
  WRITE_LIST_FIELD(options, options, options);
}

static void
_outAlterForeignServerStmt(OUT_TYPE(AlterForeignServerStmt, AlterForeignServerStmt) out, const AlterForeignServerStmt *node)
{
  WRITE_STRING_FIELD(servername, servername, servername);
  WRITE_STRING_FIELD(version, version, version);
  WRITE_LIST_FIELD(options, options, options);
  WRITE_BOOL_FIELD(has_version, has_version, has_version);
}

static void
_outCreateForeignTableStmt(OUT_TYPE(CreateForeignTableStmt, CreateForeignTableStmt) out, const CreateForeignTableStmt *node)
{
  WRITE_SPECIFIC_NODE_FIELD(CreateStmt, create_stmt, base_stmt, base, base);
  WRITE_STRING_FIELD(servername, servername, servername);
  WRITE_LIST_FIELD(options, options, options);
}

static void
_outAlterUserMappingStmt(OUT_TYPE(AlterUserMappingStmt, AlterUserMappingStmt) out, const AlterUserMappingStmt *node)
{
  WRITE_SPECIFIC_NODE_PTR_FIELD(RoleSpec, role_spec, user, user, user);
  WRITE_STRING_FIELD(servername, servername, servername);
  WRITE_LIST_FIELD(options, options, options);
}

static void
_outDropUserMappingStmt(OUT_TYPE(DropUserMappingStmt, DropUserMappingStmt) out, const DropUserMappingStmt *node)
{
  WRITE_SPECIFIC_NODE_PTR_FIELD(RoleSpec, role_spec, user, user, user);
  WRITE_STRING_FIELD(servername, servername, servername);
  WRITE_BOOL_FIELD(missing_ok, missing_ok, missing_ok);
}

static void
_outImportForeignSchemaStmt(OUT_TYPE(ImportForeignSchemaStmt, ImportForeignSchemaStmt) out, const ImportForeignSchemaStmt *node)
{
  WRITE_STRING_FIELD(server_name, server_name, server_name);
  WRITE_STRING_FIELD(remote_schema, remote_schema, remote_schema);
  WRITE_STRING_FIELD(local_schema, local_schema, local_schema);
  WRITE_ENUM_FIELD(ImportForeignSchemaType, list_type, list_type, list_type);
  WRITE_LIST_FIELD(table_list, table_list, table_list);
  WRITE_LIST_FIELD(options, options, options);
}

static void
_outCreatePolicyStmt(OUT_TYPE(CreatePolicyStmt, CreatePolicyStmt) out, const CreatePolicyStmt *node)
{
  WRITE_STRING_FIELD(policy_name, policy_name, policy_name);
  WRITE_SPECIFIC_NODE_PTR_FIELD(RangeVar, range_var, table, table, table);
  WRITE_STRING_FIELD(cmd_name, cmd_name, cmd_name);
  WRITE_BOOL_FIELD(permissive, permissive, permissive);
  WRITE_LIST_FIELD(roles, roles, roles);
  WRITE_NODE_PTR_FIELD(qual, qual, qual);
  WRITE_NODE_PTR_FIELD(with_check, with_check, with_check);
}

static void
_outAlterPolicyStmt(OUT_TYPE(AlterPolicyStmt, AlterPolicyStmt) out, const AlterPolicyStmt *node)
{
  WRITE_STRING_FIELD(policy_name, policy_name, policy_name);
  WRITE_SPECIFIC_NODE_PTR_FIELD(RangeVar, range_var, table, table, table);
  WRITE_LIST_FIELD(roles, roles, roles);
  WRITE_NODE_PTR_FIELD(qual, qual, qual);
  WRITE_NODE_PTR_FIELD(with_check, with_check, with_check);
}

static void
_outCreateAmStmt(OUT_TYPE(CreateAmStmt, CreateAmStmt) out, const CreateAmStmt *node)
{
  WRITE_STRING_FIELD(amname, amname, amname);
  WRITE_LIST_FIELD(handler_name, handler_name, handler_name);
  WRITE_CHAR_FIELD(amtype, amtype, amtype);
}

static void
_outCreateTrigStmt(OUT_TYPE(CreateTrigStmt, CreateTrigStmt) out, const CreateTrigStmt *node)
{
  WRITE_BOOL_FIELD(replace, replace, replace);
  WRITE_BOOL_FIELD(isconstraint, isconstraint, isconstraint);
  WRITE_STRING_FIELD(trigname, trigname, trigname);
  WRITE_SPECIFIC_NODE_PTR_FIELD(RangeVar, range_var, relation, relation, relation);
  WRITE_LIST_FIELD(funcname, funcname, funcname);
  WRITE_LIST_FIELD(args, args, args);
  WRITE_BOOL_FIELD(row, row, row);
  WRITE_INT_FIELD(timing, timing, timing);
  WRITE_INT_FIELD(events, events, events);
  WRITE_LIST_FIELD(columns, columns, columns);
  WRITE_NODE_PTR_FIELD(when_clause, whenClause, whenClause);
  WRITE_LIST_FIELD(transition_rels, transitionRels, transitionRels);
  WRITE_BOOL_FIELD(deferrable, deferrable, deferrable);
  WRITE_BOOL_FIELD(initdeferred, initdeferred, initdeferred);
  WRITE_SPECIFIC_NODE_PTR_FIELD(RangeVar, range_var, constrrel, constrrel, constrrel);
}

static void
_outCreateEventTrigStmt(OUT_TYPE(CreateEventTrigStmt, CreateEventTrigStmt) out, const CreateEventTrigStmt *node)
{
  WRITE_STRING_FIELD(trigname, trigname, trigname);
  WRITE_STRING_FIELD(eventname, eventname, eventname);
  WRITE_LIST_FIELD(whenclause, whenclause, whenclause);
  WRITE_LIST_FIELD(funcname, funcname, funcname);
}

static void
_outAlterEventTrigStmt(OUT_TYPE(AlterEventTrigStmt, AlterEventTrigStmt) out, const AlterEventTrigStmt *node)
{
  WRITE_STRING_FIELD(trigname, trigname, trigname);
  WRITE_CHAR_FIELD(tgenabled, tgenabled, tgenabled);
}

static void
_outCreatePLangStmt(OUT_TYPE(CreatePLangStmt, CreatePLangStmt) out, const CreatePLangStmt *node)
{
  WRITE_BOOL_FIELD(replace, replace, replace);
  WRITE_STRING_FIELD(plname, plname, plname);
  WRITE_LIST_FIELD(plhandler, plhandler, plhandler);
  WRITE_LIST_FIELD(plinline, plinline, plinline);
  WRITE_LIST_FIELD(plvalidator, plvalidator, plvalidator);
  WRITE_BOOL_FIELD(pltrusted, pltrusted, pltrusted);
}

static void
_outCreateRoleStmt(OUT_TYPE(CreateRoleStmt, CreateRoleStmt) out, const CreateRoleStmt *node)
{
  WRITE_ENUM_FIELD(RoleStmtType, stmt_type, stmt_type, stmt_type);
  WRITE_STRING_FIELD(role, role, role);
  WRITE_LIST_FIELD(options, options, options);
}

static void
_outAlterRoleStmt(OUT_TYPE(AlterRoleStmt, AlterRoleStmt) out, const AlterRoleStmt *node)
{
  WRITE_SPECIFIC_NODE_PTR_FIELD(RoleSpec, role_spec, role, role, role);
  WRITE_LIST_FIELD(options, options, options);
  WRITE_INT_FIELD(action, action, action);
}

static void
_outAlterRoleSetStmt(OUT_TYPE(AlterRoleSetStmt, AlterRoleSetStmt) out, const AlterRoleSetStmt *node)
{
  WRITE_SPECIFIC_NODE_PTR_FIELD(RoleSpec, role_spec, role, role, role);
  WRITE_STRING_FIELD(database, database, database);
  WRITE_SPECIFIC_NODE_PTR_FIELD(VariableSetStmt, variable_set_stmt, setstmt, setstmt, setstmt);
}

static void
_outDropRoleStmt(OUT_TYPE(DropRoleStmt, DropRoleStmt) out, const DropRoleStmt *node)
{
  WRITE_LIST_FIELD(roles, roles, roles);
  WRITE_BOOL_FIELD(missing_ok, missing_ok, missing_ok);
}

static void
_outCreateSeqStmt(OUT_TYPE(CreateSeqStmt, CreateSeqStmt) out, const CreateSeqStmt *node)
{
  WRITE_SPECIFIC_NODE_PTR_FIELD(RangeVar, range_var, sequence, sequence, sequence);
  WRITE_LIST_FIELD(options, options, options);
  WRITE_UINT_FIELD(owner_id, ownerId, ownerId);
  WRITE_BOOL_FIELD(for_identity, for_identity, for_identity);
  WRITE_BOOL_FIELD(if_not_exists, if_not_exists, if_not_exists);
}

static void
_outAlterSeqStmt(OUT_TYPE(AlterSeqStmt, AlterSeqStmt) out, const AlterSeqStmt *node)
{
  WRITE_SPECIFIC_NODE_PTR_FIELD(RangeVar, range_var, sequence, sequence, sequence);
  WRITE_LIST_FIELD(options, options, options);
  WRITE_BOOL_FIELD(for_identity, for_identity, for_identity);
  WRITE_BOOL_FIELD(missing_ok, missing_ok, missing_ok);
}

static void
_outDefineStmt(OUT_TYPE(DefineStmt, DefineStmt) out, const DefineStmt *node)
{
  WRITE_ENUM_FIELD(ObjectType, kind, kind, kind);
  WRITE_BOOL_FIELD(oldstyle, oldstyle, oldstyle);
  WRITE_LIST_FIELD(defnames, defnames, defnames);
  WRITE_LIST_FIELD(args, args, args);
  WRITE_LIST_FIELD(definition, definition, definition);
  WRITE_BOOL_FIELD(if_not_exists, if_not_exists, if_not_exists);
  WRITE_BOOL_FIELD(replace, replace, replace);
}

static void
_outCreateDomainStmt(OUT_TYPE(CreateDomainStmt, CreateDomainStmt) out, const CreateDomainStmt *node)
{
  WRITE_LIST_FIELD(domainname, domainname, domainname);
  WRITE_SPECIFIC_NODE_PTR_FIELD(TypeName, type_name, type_name, typeName, typeName);
  WRITE_SPECIFIC_NODE_PTR_FIELD(CollateClause, collate_clause, coll_clause, collClause, collClause);
  WRITE_LIST_FIELD(constraints, constraints, constraints);
}

static void
_outCreateOpClassStmt(OUT_TYPE(CreateOpClassStmt, CreateOpClassStmt) out, const CreateOpClassStmt *node)
{
  WRITE_LIST_FIELD(opclassname, opclassname, opclassname);
  WRITE_LIST_FIELD(opfamilyname, opfamilyname, opfamilyname);
  WRITE_STRING_FIELD(amname, amname, amname);
  WRITE_SPECIFIC_NODE_PTR_FIELD(TypeName, type_name, datatype, datatype, datatype);
  WRITE_LIST_FIELD(items, items, items);
  WRITE_BOOL_FIELD(is_default, isDefault, isDefault);
}

static void
_outCreateOpClassItem(OUT_TYPE(CreateOpClassItem, CreateOpClassItem) out, const CreateOpClassItem *node)
{
  WRITE_INT_FIELD(itemtype, itemtype, itemtype);
  WRITE_SPECIFIC_NODE_PTR_FIELD(ObjectWithArgs, object_with_args, name, name, name);
  WRITE_INT_FIELD(number, number, number);
  WRITE_LIST_FIELD(order_family, order_family, order_family);
  WRITE_LIST_FIELD(class_args, class_args, class_args);
  WRITE_SPECIFIC_NODE_PTR_FIELD(TypeName, type_name, storedtype, storedtype, storedtype);
}

static void
_outCreateOpFamilyStmt(OUT_TYPE(CreateOpFamilyStmt, CreateOpFamilyStmt) out, const CreateOpFamilyStmt *node)
{
  WRITE_LIST_FIELD(opfamilyname, opfamilyname, opfamilyname);
  WRITE_STRING_FIELD(amname, amname, amname);
}

static void
_outAlterOpFamilyStmt(OUT_TYPE(AlterOpFamilyStmt, AlterOpFamilyStmt) out, const AlterOpFamilyStmt *node)
{
  WRITE_LIST_FIELD(opfamilyname, opfamilyname, opfamilyname);
  WRITE_STRING_FIELD(amname, amname, amname);
  WRITE_BOOL_FIELD(is_drop, isDrop, isDrop);
  WRITE_LIST_FIELD(items, items, items);
}

static void
_outDropStmt(OUT_TYPE(DropStmt, DropStmt) out, const DropStmt *node)
{
  WRITE_LIST_FIELD(objects, objects, objects);
  WRITE_ENUM_FIELD(ObjectType, remove_type, removeType, removeType);
  WRITE_ENUM_FIELD(DropBehavior, behavior, behavior, behavior);
  WRITE_BOOL_FIELD(missing_ok, missing_ok, missing_ok);
  WRITE_BOOL_FIELD(concurrent, concurrent, concurrent);
}

static void
_outTruncateStmt(OUT_TYPE(TruncateStmt, TruncateStmt) out, const TruncateStmt *node)
{
  WRITE_LIST_FIELD(relations, relations, relations);
  WRITE_BOOL_FIELD(restart_seqs, restart_seqs, restart_seqs);
  WRITE_ENUM_FIELD(DropBehavior, behavior, behavior, behavior);
}

static void
_outCommentStmt(OUT_TYPE(CommentStmt, CommentStmt) out, const CommentStmt *node)
{
  WRITE_ENUM_FIELD(ObjectType, objtype, objtype, objtype);
  WRITE_NODE_PTR_FIELD(object, object, object);
  WRITE_STRING_FIELD(comment, comment, comment);
}

static void
_outSecLabelStmt(OUT_TYPE(SecLabelStmt, SecLabelStmt) out, const SecLabelStmt *node)
{
  WRITE_ENUM_FIELD(ObjectType, objtype, objtype, objtype);
  WRITE_NODE_PTR_FIELD(object, object, object);
  WRITE_STRING_FIELD(provider, provider, provider);
  WRITE_STRING_FIELD(label, label, label);
}

static void
_outDeclareCursorStmt(OUT_TYPE(DeclareCursorStmt, DeclareCursorStmt) out, const DeclareCursorStmt *node)
{
  WRITE_STRING_FIELD(portalname, portalname, portalname);
  WRITE_INT_FIELD(options, options, options);
  WRITE_NODE_PTR_FIELD(query, query, query);
}

static void
_outClosePortalStmt(OUT_TYPE(ClosePortalStmt, ClosePortalStmt) out, const ClosePortalStmt *node)
{
  WRITE_STRING_FIELD(portalname, portalname, portalname);
}

static void
_outFetchStmt(OUT_TYPE(FetchStmt, FetchStmt) out, const FetchStmt *node)
{
  WRITE_ENUM_FIELD(FetchDirection, direction, direction, direction);
  WRITE_LONG_FIELD(how_many, howMany, howMany);
  WRITE_STRING_FIELD(portalname, portalname, portalname);
  WRITE_BOOL_FIELD(ismove, ismove, ismove);
}

static void
_outIndexStmt(OUT_TYPE(IndexStmt, IndexStmt) out, const IndexStmt *node)
{
  WRITE_STRING_FIELD(idxname, idxname, idxname);
  WRITE_SPECIFIC_NODE_PTR_FIELD(RangeVar, range_var, relation, relation, relation);
  WRITE_STRING_FIELD(access_method, accessMethod, accessMethod);
  WRITE_STRING_FIELD(table_space, tableSpace, tableSpace);
  WRITE_LIST_FIELD(index_params, indexParams, indexParams);
  WRITE_LIST_FIELD(index_including_params, indexIncludingParams, indexIncludingParams);
  WRITE_LIST_FIELD(options, options, options);
  WRITE_NODE_PTR_FIELD(where_clause, whereClause, whereClause);
  WRITE_LIST_FIELD(exclude_op_names, excludeOpNames, excludeOpNames);
  WRITE_STRING_FIELD(idxcomment, idxcomment, idxcomment);
  WRITE_UINT_FIELD(index_oid, indexOid, indexOid);
  WRITE_UINT_FIELD(old_number, oldNumber, oldNumber);
  WRITE_UINT_FIELD(old_create_subid, oldCreateSubid, oldCreateSubid);
  WRITE_UINT_FIELD(old_first_relfilelocator_subid, oldFirstRelfilelocatorSubid, oldFirstRelfilelocatorSubid);
  WRITE_BOOL_FIELD(unique, unique, unique);
  WRITE_BOOL_FIELD(nulls_not_distinct, nulls_not_distinct, nulls_not_distinct);
  WRITE_BOOL_FIELD(primary, primary, primary);
  WRITE_BOOL_FIELD(isconstraint, isconstraint, isconstraint);
  WRITE_BOOL_FIELD(deferrable, deferrable, deferrable);
  WRITE_BOOL_FIELD(initdeferred, initdeferred, initdeferred);
  WRITE_BOOL_FIELD(transformed, transformed, transformed);
  WRITE_BOOL_FIELD(concurrent, concurrent, concurrent);
  WRITE_BOOL_FIELD(if_not_exists, if_not_exists, if_not_exists);
  WRITE_BOOL_FIELD(reset_default_tblspc, reset_default_tblspc, reset_default_tblspc);
}

static void
_outCreateStatsStmt(OUT_TYPE(CreateStatsStmt, CreateStatsStmt) out, const CreateStatsStmt *node)
{
  WRITE_LIST_FIELD(defnames, defnames, defnames);
  WRITE_LIST_FIELD(stat_types, stat_types, stat_types);
  WRITE_LIST_FIELD(exprs, exprs, exprs);
  WRITE_LIST_FIELD(relations, relations, relations);
  WRITE_STRING_FIELD(stxcomment, stxcomment, stxcomment);
  WRITE_BOOL_FIELD(transformed, transformed, transformed);
  WRITE_BOOL_FIELD(if_not_exists, if_not_exists, if_not_exists);
}

static void
_outStatsElem(OUT_TYPE(StatsElem, StatsElem) out, const StatsElem *node)
{
  WRITE_STRING_FIELD(name, name, name);
  WRITE_NODE_PTR_FIELD(expr, expr, expr);
}

static void
_outCreateFunctionStmt(OUT_TYPE(CreateFunctionStmt, CreateFunctionStmt) out, const CreateFunctionStmt *node)
{
  WRITE_BOOL_FIELD(is_procedure, is_procedure, is_procedure);
  WRITE_BOOL_FIELD(replace, replace, replace);
  WRITE_LIST_FIELD(funcname, funcname, funcname);
  WRITE_LIST_FIELD(parameters, parameters, parameters);
  WRITE_SPECIFIC_NODE_PTR_FIELD(TypeName, type_name, return_type, returnType, returnType);
  WRITE_LIST_FIELD(options, options, options);
  WRITE_NODE_PTR_FIELD(sql_body, sql_body, sql_body);
}

static void
_outFunctionParameter(OUT_TYPE(FunctionParameter, FunctionParameter) out, const FunctionParameter *node)
{
  WRITE_STRING_FIELD(name, name, name);
  WRITE_SPECIFIC_NODE_PTR_FIELD(TypeName, type_name, arg_type, argType, argType);
  WRITE_ENUM_FIELD(FunctionParameterMode, mode, mode, mode);
  WRITE_NODE_PTR_FIELD(defexpr, defexpr, defexpr);
}

static void
_outAlterFunctionStmt(OUT_TYPE(AlterFunctionStmt, AlterFunctionStmt) out, const AlterFunctionStmt *node)
{
  WRITE_ENUM_FIELD(ObjectType, objtype, objtype, objtype);
  WRITE_SPECIFIC_NODE_PTR_FIELD(ObjectWithArgs, object_with_args, func, func, func);
  WRITE_LIST_FIELD(actions, actions, actions);
}

static void
_outDoStmt(OUT_TYPE(DoStmt, DoStmt) out, const DoStmt *node)
{
  WRITE_LIST_FIELD(args, args, args);
}

static void
_outInlineCodeBlock(OUT_TYPE(InlineCodeBlock, InlineCodeBlock) out, const InlineCodeBlock *node)
{
  WRITE_STRING_FIELD(source_text, source_text, source_text);
  WRITE_UINT_FIELD(lang_oid, langOid, langOid);
  WRITE_BOOL_FIELD(lang_is_trusted, langIsTrusted, langIsTrusted);
  WRITE_BOOL_FIELD(atomic, atomic, atomic);
}

static void
_outCallContext(OUT_TYPE(CallContext, CallContext) out, const CallContext *node)
{
  WRITE_BOOL_FIELD(atomic, atomic, atomic);
}

static void
_outRenameStmt(OUT_TYPE(RenameStmt, RenameStmt) out, const RenameStmt *node)
{
  WRITE_ENUM_FIELD(ObjectType, rename_type, renameType, renameType);
  WRITE_ENUM_FIELD(ObjectType, relation_type, relationType, relationType);
  WRITE_SPECIFIC_NODE_PTR_FIELD(RangeVar, range_var, relation, relation, relation);
  WRITE_NODE_PTR_FIELD(object, object, object);
  WRITE_STRING_FIELD(subname, subname, subname);
  WRITE_STRING_FIELD(newname, newname, newname);
  WRITE_ENUM_FIELD(DropBehavior, behavior, behavior, behavior);
  WRITE_BOOL_FIELD(missing_ok, missing_ok, missing_ok);
}

static void
_outAlterObjectDependsStmt(OUT_TYPE(AlterObjectDependsStmt, AlterObjectDependsStmt) out, const AlterObjectDependsStmt *node)
{
  WRITE_ENUM_FIELD(ObjectType, object_type, objectType, objectType);
  WRITE_SPECIFIC_NODE_PTR_FIELD(RangeVar, range_var, relation, relation, relation);
  WRITE_NODE_PTR_FIELD(object, object, object);
  WRITE_SPECIFIC_NODE_PTR_FIELD(String, string, extname, extname, extname);
  WRITE_BOOL_FIELD(remove, remove, remove);
}

static void
_outAlterObjectSchemaStmt(OUT_TYPE(AlterObjectSchemaStmt, AlterObjectSchemaStmt) out, const AlterObjectSchemaStmt *node)
{
  WRITE_ENUM_FIELD(ObjectType, object_type, objectType, objectType);
  WRITE_SPECIFIC_NODE_PTR_FIELD(RangeVar, range_var, relation, relation, relation);
  WRITE_NODE_PTR_FIELD(object, object, object);
  WRITE_STRING_FIELD(newschema, newschema, newschema);
  WRITE_BOOL_FIELD(missing_ok, missing_ok, missing_ok);
}

static void
_outAlterOwnerStmt(OUT_TYPE(AlterOwnerStmt, AlterOwnerStmt) out, const AlterOwnerStmt *node)
{
  WRITE_ENUM_FIELD(ObjectType, object_type, objectType, objectType);
  WRITE_SPECIFIC_NODE_PTR_FIELD(RangeVar, range_var, relation, relation, relation);
  WRITE_NODE_PTR_FIELD(object, object, object);
  WRITE_SPECIFIC_NODE_PTR_FIELD(RoleSpec, role_spec, newowner, newowner, newowner);
}

static void
_outAlterOperatorStmt(OUT_TYPE(AlterOperatorStmt, AlterOperatorStmt) out, const AlterOperatorStmt *node)
{
  WRITE_SPECIFIC_NODE_PTR_FIELD(ObjectWithArgs, object_with_args, opername, opername, opername);
  WRITE_LIST_FIELD(options, options, options);
}

static void
_outAlterTypeStmt(OUT_TYPE(AlterTypeStmt, AlterTypeStmt) out, const AlterTypeStmt *node)
{
  WRITE_LIST_FIELD(type_name, typeName, typeName);
  WRITE_LIST_FIELD(options, options, options);
}

static void
_outRuleStmt(OUT_TYPE(RuleStmt, RuleStmt) out, const RuleStmt *node)
{
  WRITE_SPECIFIC_NODE_PTR_FIELD(RangeVar, range_var, relation, relation, relation);
  WRITE_STRING_FIELD(rulename, rulename, rulename);
  WRITE_NODE_PTR_FIELD(where_clause, whereClause, whereClause);
  WRITE_ENUM_FIELD(CmdType, event, event, event);
  WRITE_BOOL_FIELD(instead, instead, instead);
  WRITE_LIST_FIELD(actions, actions, actions);
  WRITE_BOOL_FIELD(replace, replace, replace);
}

static void
_outNotifyStmt(OUT_TYPE(NotifyStmt, NotifyStmt) out, const NotifyStmt *node)
{
  WRITE_STRING_FIELD(conditionname, conditionname, conditionname);
  WRITE_STRING_FIELD(payload, payload, payload);
}

static void
_outListenStmt(OUT_TYPE(ListenStmt, ListenStmt) out, const ListenStmt *node)
{
  WRITE_STRING_FIELD(conditionname, conditionname, conditionname);
}

static void
_outUnlistenStmt(OUT_TYPE(UnlistenStmt, UnlistenStmt) out, const UnlistenStmt *node)
{
  WRITE_STRING_FIELD(conditionname, conditionname, conditionname);
}

static void
_outCompositeTypeStmt(OUT_TYPE(CompositeTypeStmt, CompositeTypeStmt) out, const CompositeTypeStmt *node)
{
  WRITE_SPECIFIC_NODE_PTR_FIELD(RangeVar, range_var, typevar, typevar, typevar);
  WRITE_LIST_FIELD(coldeflist, coldeflist, coldeflist);
}

static void
_outCreateRangeStmt(OUT_TYPE(CreateRangeStmt, CreateRangeStmt) out, const CreateRangeStmt *node)
{
  WRITE_LIST_FIELD(type_name, typeName, typeName);
  WRITE_LIST_FIELD(params, params, params);
}

static void
_outAlterEnumStmt(OUT_TYPE(AlterEnumStmt, AlterEnumStmt) out, const AlterEnumStmt *node)
{
  WRITE_LIST_FIELD(type_name, typeName, typeName);
  WRITE_STRING_FIELD(old_val, oldVal, oldVal);
  WRITE_STRING_FIELD(new_val, newVal, newVal);
  WRITE_STRING_FIELD(new_val_neighbor, newValNeighbor, newValNeighbor);
  WRITE_BOOL_FIELD(new_val_is_after, newValIsAfter, newValIsAfter);
  WRITE_BOOL_FIELD(skip_if_new_val_exists, skipIfNewValExists, skipIfNewValExists);
}

static void
_outViewStmt(OUT_TYPE(ViewStmt, ViewStmt) out, const ViewStmt *node)
{
  WRITE_SPECIFIC_NODE_PTR_FIELD(RangeVar, range_var, view, view, view);
  WRITE_LIST_FIELD(aliases, aliases, aliases);
  WRITE_NODE_PTR_FIELD(query, query, query);
  WRITE_BOOL_FIELD(replace, replace, replace);
  WRITE_LIST_FIELD(options, options, options);
  WRITE_ENUM_FIELD(ViewCheckOption, with_check_option, withCheckOption, withCheckOption);
}

static void
_outLoadStmt(OUT_TYPE(LoadStmt, LoadStmt) out, const LoadStmt *node)
{
  WRITE_STRING_FIELD(filename, filename, filename);
}

static void
_outCreatedbStmt(OUT_TYPE(CreatedbStmt, CreatedbStmt) out, const CreatedbStmt *node)
{
  WRITE_STRING_FIELD(dbname, dbname, dbname);
  WRITE_LIST_FIELD(options, options, options);
}

static void
_outAlterDatabaseStmt(OUT_TYPE(AlterDatabaseStmt, AlterDatabaseStmt) out, const AlterDatabaseStmt *node)
{
  WRITE_STRING_FIELD(dbname, dbname, dbname);
  WRITE_LIST_FIELD(options, options, options);
}

static void
_outAlterDatabaseRefreshCollStmt(OUT_TYPE(AlterDatabaseRefreshCollStmt, AlterDatabaseRefreshCollStmt) out, const AlterDatabaseRefreshCollStmt *node)
{
  WRITE_STRING_FIELD(dbname, dbname, dbname);
}

static void
_outAlterDatabaseSetStmt(OUT_TYPE(AlterDatabaseSetStmt, AlterDatabaseSetStmt) out, const AlterDatabaseSetStmt *node)
{
  WRITE_STRING_FIELD(dbname, dbname, dbname);
  WRITE_SPECIFIC_NODE_PTR_FIELD(VariableSetStmt, variable_set_stmt, setstmt, setstmt, setstmt);
}

static void
_outDropdbStmt(OUT_TYPE(DropdbStmt, DropdbStmt) out, const DropdbStmt *node)
{
  WRITE_STRING_FIELD(dbname, dbname, dbname);
  WRITE_BOOL_FIELD(missing_ok, missing_ok, missing_ok);
  WRITE_LIST_FIELD(options, options, options);
}

static void
_outAlterSystemStmt(OUT_TYPE(AlterSystemStmt, AlterSystemStmt) out, const AlterSystemStmt *node)
{
  WRITE_SPECIFIC_NODE_PTR_FIELD(VariableSetStmt, variable_set_stmt, setstmt, setstmt, setstmt);
}

static void
_outClusterStmt(OUT_TYPE(ClusterStmt, ClusterStmt) out, const ClusterStmt *node)
{
  WRITE_SPECIFIC_NODE_PTR_FIELD(RangeVar, range_var, relation, relation, relation);
  WRITE_STRING_FIELD(indexname, indexname, indexname);
  WRITE_LIST_FIELD(params, params, params);
}

static void
_outVacuumStmt(OUT_TYPE(VacuumStmt, VacuumStmt) out, const VacuumStmt *node)
{
  WRITE_LIST_FIELD(options, options, options);
  WRITE_LIST_FIELD(rels, rels, rels);
  WRITE_BOOL_FIELD(is_vacuumcmd, is_vacuumcmd, is_vacuumcmd);
}

static void
_outVacuumRelation(OUT_TYPE(VacuumRelation, VacuumRelation) out, const VacuumRelation *node)
{
  WRITE_SPECIFIC_NODE_PTR_FIELD(RangeVar, range_var, relation, relation, relation);
  WRITE_UINT_FIELD(oid, oid, oid);
  WRITE_LIST_FIELD(va_cols, va_cols, va_cols);
}

static void
_outExplainStmt(OUT_TYPE(ExplainStmt, ExplainStmt) out, const ExplainStmt *node)
{
  WRITE_NODE_PTR_FIELD(query, query, query);
  WRITE_LIST_FIELD(options, options, options);
}

static void
_outCreateTableAsStmt(OUT_TYPE(CreateTableAsStmt, CreateTableAsStmt) out, const CreateTableAsStmt *node)
{
  WRITE_NODE_PTR_FIELD(query, query, query);
  WRITE_SPECIFIC_NODE_PTR_FIELD(IntoClause, into_clause, into, into, into);
  WRITE_ENUM_FIELD(ObjectType, objtype, objtype, objtype);
  WRITE_BOOL_FIELD(is_select_into, is_select_into, is_select_into);
  WRITE_BOOL_FIELD(if_not_exists, if_not_exists, if_not_exists);
}

static void
_outRefreshMatViewStmt(OUT_TYPE(RefreshMatViewStmt, RefreshMatViewStmt) out, const RefreshMatViewStmt *node)
{
  WRITE_BOOL_FIELD(concurrent, concurrent, concurrent);
  WRITE_BOOL_FIELD(skip_data, skipData, skipData);
  WRITE_SPECIFIC_NODE_PTR_FIELD(RangeVar, range_var, relation, relation, relation);
}

static void
_outCheckPointStmt(OUT_TYPE(CheckPointStmt, CheckPointStmt) out, const CheckPointStmt *node)
{
}

static void
_outDiscardStmt(OUT_TYPE(DiscardStmt, DiscardStmt) out, const DiscardStmt *node)
{
  WRITE_ENUM_FIELD(DiscardMode, target, target, target);
}

static void
_outLockStmt(OUT_TYPE(LockStmt, LockStmt) out, const LockStmt *node)
{
  WRITE_LIST_FIELD(relations, relations, relations);
  WRITE_INT_FIELD(mode, mode, mode);
  WRITE_BOOL_FIELD(nowait, nowait, nowait);
}

static void
_outConstraintsSetStmt(OUT_TYPE(ConstraintsSetStmt, ConstraintsSetStmt) out, const ConstraintsSetStmt *node)
{
  WRITE_LIST_FIELD(constraints, constraints, constraints);
  WRITE_BOOL_FIELD(deferred, deferred, deferred);
}

static void
_outReindexStmt(OUT_TYPE(ReindexStmt, ReindexStmt) out, const ReindexStmt *node)
{
  WRITE_ENUM_FIELD(ReindexObjectType, kind, kind, kind);
  WRITE_SPECIFIC_NODE_PTR_FIELD(RangeVar, range_var, relation, relation, relation);
  WRITE_STRING_FIELD(name, name, name);
  WRITE_LIST_FIELD(params, params, params);
}

static void
_outCreateConversionStmt(OUT_TYPE(CreateConversionStmt, CreateConversionStmt) out, const CreateConversionStmt *node)
{
  WRITE_LIST_FIELD(conversion_name, conversion_name, conversion_name);
  WRITE_STRING_FIELD(for_encoding_name, for_encoding_name, for_encoding_name);
  WRITE_STRING_FIELD(to_encoding_name, to_encoding_name, to_encoding_name);
  WRITE_LIST_FIELD(func_name, func_name, func_name);
  WRITE_BOOL_FIELD(def, def, def);
}

static void
_outCreateCastStmt(OUT_TYPE(CreateCastStmt, CreateCastStmt) out, const CreateCastStmt *node)
{
  WRITE_SPECIFIC_NODE_PTR_FIELD(TypeName, type_name, sourcetype, sourcetype, sourcetype);
  WRITE_SPECIFIC_NODE_PTR_FIELD(TypeName, type_name, targettype, targettype, targettype);
  WRITE_SPECIFIC_NODE_PTR_FIELD(ObjectWithArgs, object_with_args, func, func, func);
  WRITE_ENUM_FIELD(CoercionContext, context, context, context);
  WRITE_BOOL_FIELD(inout, inout, inout);
}

static void
_outCreateTransformStmt(OUT_TYPE(CreateTransformStmt, CreateTransformStmt) out, const CreateTransformStmt *node)
{
  WRITE_BOOL_FIELD(replace, replace, replace);
  WRITE_SPECIFIC_NODE_PTR_FIELD(TypeName, type_name, type_name, type_name, type_name);
  WRITE_STRING_FIELD(lang, lang, lang);
  WRITE_SPECIFIC_NODE_PTR_FIELD(ObjectWithArgs, object_with_args, fromsql, fromsql, fromsql);
  WRITE_SPECIFIC_NODE_PTR_FIELD(ObjectWithArgs, object_with_args, tosql, tosql, tosql);
}

static void
_outPrepareStmt(OUT_TYPE(PrepareStmt, PrepareStmt) out, const PrepareStmt *node)
{
  WRITE_STRING_FIELD(name, name, name);
  WRITE_LIST_FIELD(argtypes, argtypes, argtypes);
  WRITE_NODE_PTR_FIELD(query, query, query);
}

static void
_outExecuteStmt(OUT_TYPE(ExecuteStmt, ExecuteStmt) out, const ExecuteStmt *node)
{
  WRITE_STRING_FIELD(name, name, name);
  WRITE_LIST_FIELD(params, params, params);
}

static void
_outDropOwnedStmt(OUT_TYPE(DropOwnedStmt, DropOwnedStmt) out, const DropOwnedStmt *node)
{
  WRITE_LIST_FIELD(roles, roles, roles);
  WRITE_ENUM_FIELD(DropBehavior, behavior, behavior, behavior);
}

static void
_outReassignOwnedStmt(OUT_TYPE(ReassignOwnedStmt, ReassignOwnedStmt) out, const ReassignOwnedStmt *node)
{
  WRITE_LIST_FIELD(roles, roles, roles);
  WRITE_SPECIFIC_NODE_PTR_FIELD(RoleSpec, role_spec, newrole, newrole, newrole);
}

static void
_outAlterTSDictionaryStmt(OUT_TYPE(AlterTSDictionaryStmt, AlterTSDictionaryStmt) out, const AlterTSDictionaryStmt *node)
{
  WRITE_LIST_FIELD(dictname, dictname, dictname);
  WRITE_LIST_FIELD(options, options, options);
}

static void
_outAlterTSConfigurationStmt(OUT_TYPE(AlterTSConfigurationStmt, AlterTSConfigurationStmt) out, const AlterTSConfigurationStmt *node)
{
  WRITE_ENUM_FIELD(AlterTSConfigType, kind, kind, kind);
  WRITE_LIST_FIELD(cfgname, cfgname, cfgname);
  WRITE_LIST_FIELD(tokentype, tokentype, tokentype);
  WRITE_LIST_FIELD(dicts, dicts, dicts);
  WRITE_BOOL_FIELD(override, override, override);
  WRITE_BOOL_FIELD(replace, replace, replace);
  WRITE_BOOL_FIELD(missing_ok, missing_ok, missing_ok);
}

static void
_outPublicationTable(OUT_TYPE(PublicationTable, PublicationTable) out, const PublicationTable *node)
{
  WRITE_SPECIFIC_NODE_PTR_FIELD(RangeVar, range_var, relation, relation, relation);
  WRITE_NODE_PTR_FIELD(where_clause, whereClause, whereClause);
  WRITE_LIST_FIELD(columns, columns, columns);
}

static void
_outCreatePublicationStmt(OUT_TYPE(CreatePublicationStmt, CreatePublicationStmt) out, const CreatePublicationStmt *node)
{
  WRITE_STRING_FIELD(pubname, pubname, pubname);
  WRITE_LIST_FIELD(options, options, options);
  WRITE_LIST_FIELD(pubobjects, pubobjects, pubobjects);
  WRITE_BOOL_FIELD(for_all_tables, for_all_tables, for_all_tables);
}

static void
_outAlterPublicationStmt(OUT_TYPE(AlterPublicationStmt, AlterPublicationStmt) out, const AlterPublicationStmt *node)
{
  WRITE_STRING_FIELD(pubname, pubname, pubname);
  WRITE_LIST_FIELD(options, options, options);
  WRITE_LIST_FIELD(pubobjects, pubobjects, pubobjects);
  WRITE_BOOL_FIELD(for_all_tables, for_all_tables, for_all_tables);
  WRITE_ENUM_FIELD(AlterPublicationAction, action, action, action);
}

static void
_outCreateSubscriptionStmt(OUT_TYPE(CreateSubscriptionStmt, CreateSubscriptionStmt) out, const CreateSubscriptionStmt *node)
{
  WRITE_STRING_FIELD(subname, subname, subname);
  WRITE_STRING_FIELD(conninfo, conninfo, conninfo);
  WRITE_LIST_FIELD(publication, publication, publication);
  WRITE_LIST_FIELD(options, options, options);
}

static void
_outAlterSubscriptionStmt(OUT_TYPE(AlterSubscriptionStmt, AlterSubscriptionStmt) out, const AlterSubscriptionStmt *node)
{
  WRITE_ENUM_FIELD(AlterSubscriptionType, kind, kind, kind);
  WRITE_STRING_FIELD(subname, subname, subname);
  WRITE_STRING_FIELD(conninfo, conninfo, conninfo);
  WRITE_LIST_FIELD(publication, publication, publication);
  WRITE_LIST_FIELD(options, options, options);
}

static void
_outDropSubscriptionStmt(OUT_TYPE(DropSubscriptionStmt, DropSubscriptionStmt) out, const DropSubscriptionStmt *node)
{
  WRITE_STRING_FIELD(subname, subname, subname);
  WRITE_BOOL_FIELD(missing_ok, missing_ok, missing_ok);
  WRITE_ENUM_FIELD(DropBehavior, behavior, behavior, behavior);
}

static void
_outNode(StringInfo out, const void *obj)
{
	if (obj == NULL)
	{
		appendStringInfoString(out, "null");
	}
	else
	{
		appendStringInfoChar(out, '{');
		switch (nodeTag(obj))
		{
            case T_Integer:
            OUT_NODE(Integer, Integer, integer, INTEGER, Integer, integer);
            break;
            case T_Boolean:
            OUT_NODE(Boolean, Boolean, boolean, BOOLEAN, Boolean, boolean);
            break;
            case T_Float:
            OUT_NODE(Float, Float, float, FLOAT, Float, float_);
            break;
            case T_String:
            OUT_NODE(String, String, string, STRING, String, string);
            break;
            case T_BitString:
            OUT_NODE(BitString, BitString, bit_string, BIT_STRING, BitString, bit_string);
            break;
            case T_List:
            OUT_NODE(List, List, list, LIST, List, list);
            break;
            case T_IntList:
            OUT_NODE(IntList, IntList, int_list, INT_LIST, List, int_list);
            break;
            case T_OidList:
            OUT_NODE(OidList, OidList, oid_list, OID_LIST, List, oid_list);
            break;
            case T_A_Const:
            OUT_NODE(A_Const, AConst, a__const, A_CONST, A_Const, a_const);
            break;
            case T_Alias:
            OUT_NODE(Alias, Alias, alias, ALIAS, Alias, alias);
            break;
            case T_RangeVar:
            OUT_NODE(RangeVar, RangeVar, range_var, RANGE_VAR, RangeVar, range_var);
            break;
            case T_IntoClause:
            OUT_NODE(IntoClause, IntoClause, into_clause, INTO_CLAUSE, IntoClause, into_clause);
            break;
            case T_Var:
            OUT_NODE(Var, Var, var, VAR, Var, var);
            break;
            case T_Param:
            OUT_NODE(Param, Param, param, PARAM, Param, param);
            break;
            case T_SubscriptingRef:
            OUT_NODE(SubscriptingRef, SubscriptingRef, subscripting_ref, SUBSCRIPTING_REF, SubscriptingRef, subscripting_ref);
            break;
            case T_NamedArgExpr:
            OUT_NODE(NamedArgExpr, NamedArgExpr, named_arg_expr, NAMED_ARG_EXPR, NamedArgExpr, named_arg_expr);
            break;
            case T_OpExpr:
            OUT_NODE(OpExpr, OpExpr, op_expr, OP_EXPR, OpExpr, op_expr);
            break;
            case T_DistinctExpr:
            OUT_NODE(DistinctExpr, DistinctExpr, distinct_expr, DISTINCT_EXPR, DistinctExpr, distinct_expr);
            break;
            case T_NullIfExpr:
            OUT_NODE(NullIfExpr, NullIfExpr, null_if_expr, NULL_IF_EXPR, NullIfExpr, null_if_expr);
            break;
            case T_ScalarArrayOpExpr:
            OUT_NODE(ScalarArrayOpExpr, ScalarArrayOpExpr, scalar_array_op_expr, SCALAR_ARRAY_OP_EXPR, ScalarArrayOpExpr, scalar_array_op_expr);
            break;
            case T_BoolExpr:
            OUT_NODE(BoolExpr, BoolExpr, bool_expr, BOOL_EXPR, BoolExpr, bool_expr);
            break;
            case T_SubLink:
            OUT_NODE(SubLink, SubLink, sub_link, SUB_LINK, SubLink, sub_link);
            break;
            case T_SubPlan:
            OUT_NODE(SubPlan, SubPlan, sub_plan, SUB_PLAN, SubPlan, sub_plan);
            break;
            case T_AlternativeSubPlan:
            OUT_NODE(AlternativeSubPlan, AlternativeSubPlan, alternative_sub_plan, ALTERNATIVE_SUB_PLAN, AlternativeSubPlan, alternative_sub_plan);
            break;
            case T_FieldSelect:
            OUT_NODE(FieldSelect, FieldSelect, field_select, FIELD_SELECT, FieldSelect, field_select);
            break;
            case T_FieldStore:
            OUT_NODE(FieldStore, FieldStore, field_store, FIELD_STORE, FieldStore, field_store);
            break;
            case T_RelabelType:
            OUT_NODE(RelabelType, RelabelType, relabel_type, RELABEL_TYPE, RelabelType, relabel_type);
            break;
            case T_CoerceViaIO:
            OUT_NODE(CoerceViaIO, CoerceViaIO, coerce_via_io, COERCE_VIA_IO, CoerceViaIO, coerce_via_io);
            break;
            case T_ArrayCoerceExpr:
            OUT_NODE(ArrayCoerceExpr, ArrayCoerceExpr, array_coerce_expr, ARRAY_COERCE_EXPR, ArrayCoerceExpr, array_coerce_expr);
            break;
            case T_ConvertRowtypeExpr:
            OUT_NODE(ConvertRowtypeExpr, ConvertRowtypeExpr, convert_rowtype_expr, CONVERT_ROWTYPE_EXPR, ConvertRowtypeExpr, convert_rowtype_expr);
            break;
            case T_CollateExpr:
            OUT_NODE(CollateExpr, CollateExpr, collate_expr, COLLATE_EXPR, CollateExpr, collate_expr);
            break;
            case T_CaseExpr:
            OUT_NODE(CaseExpr, CaseExpr, case_expr, CASE_EXPR, CaseExpr, case_expr);
            break;
            case T_CaseWhen:
            OUT_NODE(CaseWhen, CaseWhen, case_when, CASE_WHEN, CaseWhen, case_when);
            break;
            case T_CaseTestExpr:
            OUT_NODE(CaseTestExpr, CaseTestExpr, case_test_expr, CASE_TEST_EXPR, CaseTestExpr, case_test_expr);
            break;
            case T_ArrayExpr:
            OUT_NODE(ArrayExpr, ArrayExpr, array_expr, ARRAY_EXPR, ArrayExpr, array_expr);
            break;
            case T_RowExpr:
            OUT_NODE(RowExpr, RowExpr, row_expr, ROW_EXPR, RowExpr, row_expr);
            break;
            case T_NullTest:
            OUT_NODE(NullTest, NullTest, null_test, NULL_TEST, NullTest, null_test);
            break;
            case T_BooleanTest:
            OUT_NODE(BooleanTest, BooleanTest, boolean_test, BOOLEAN_TEST, BooleanTest, boolean_test);
            break;
            case T_CoerceToDomain:
            OUT_NODE(CoerceToDomain, CoerceToDomain, coerce_to_domain, COERCE_TO_DOMAIN, CoerceToDomain, coerce_to_domain);
            break;
            case T_CoerceToDomainValue:
            OUT_NODE(CoerceToDomainValue, CoerceToDomainValue, coerce_to_domain_value, COERCE_TO_DOMAIN_VALUE, CoerceToDomainValue, coerce_to_domain_value);
            break;
            case T_SetToDefault:
            OUT_NODE(SetToDefault, SetToDefault, set_to_default, SET_TO_DEFAULT, SetToDefault, set_to_default);
            break;
            case T_CurrentOfExpr:
            OUT_NODE(CurrentOfExpr, CurrentOfExpr, current_of_expr, CURRENT_OF_EXPR, CurrentOfExpr, current_of_expr);
            break;
            case T_NextValueExpr:
            OUT_NODE(NextValueExpr, NextValueExpr, next_value_expr, NEXT_VALUE_EXPR, NextValueExpr, next_value_expr);
            break;
            case T_InferenceElem:
            OUT_NODE(InferenceElem, InferenceElem, inference_elem, INFERENCE_ELEM, InferenceElem, inference_elem);
            break;
            case T_TargetEntry:
            OUT_NODE(TargetEntry, TargetEntry, target_entry, TARGET_ENTRY, TargetEntry, target_entry);
            break;
            case T_RangeTblRef:
            OUT_NODE(RangeTblRef, RangeTblRef, range_tbl_ref, RANGE_TBL_REF, RangeTblRef, range_tbl_ref);
            break;
            case T_JoinExpr:
            OUT_NODE(JoinExpr, JoinExpr, join_expr, JOIN_EXPR, JoinExpr, join_expr);
            break;
            case T_FromExpr:
            OUT_NODE(FromExpr, FromExpr, from_expr, FROM_EXPR, FromExpr, from_expr);
            break;
            case T_OnConflictExpr:
            OUT_NODE(OnConflictExpr, OnConflictExpr, on_conflict_expr, ON_CONFLICT_EXPR, OnConflictExpr, on_conflict_expr);
            break;
            case T_TypeName:
            OUT_NODE(TypeName, TypeName, type_name, TYPE_NAME, TypeName, type_name);
            break;
            case T_ColumnRef:
            OUT_NODE(ColumnRef, ColumnRef, column_ref, COLUMN_REF, ColumnRef, column_ref);
            break;
            case T_ParamRef:
            OUT_NODE(ParamRef, ParamRef, param_ref, PARAM_REF, ParamRef, param_ref);
            break;
            case T_A_Expr:
            OUT_NODE(A_Expr, AExpr, a__expr, A_EXPR, A_Expr, a_expr);
            break;
            case T_TypeCast:
            OUT_NODE(TypeCast, TypeCast, type_cast, TYPE_CAST, TypeCast, type_cast);
            break;
            case T_CollateClause:
            OUT_NODE(CollateClause, CollateClause, collate_clause, COLLATE_CLAUSE, CollateClause, collate_clause);
            break;
            case T_RoleSpec:
            OUT_NODE(RoleSpec, RoleSpec, role_spec, ROLE_SPEC, RoleSpec, role_spec);
            break;
            case T_FuncCall:
            OUT_NODE(FuncCall, FuncCall, func_call, FUNC_CALL, FuncCall, func_call);
            break;
            case T_A_Star:
            OUT_NODE(A_Star, AStar, a__star, A_STAR, A_Star, a_star);
            break;
            case T_A_Indices:
            OUT_NODE(A_Indices, AIndices, a__indices, A_INDICES, A_Indices, a_indices);
            break;
            case T_A_Indirection:
            OUT_NODE(A_Indirection, AIndirection, a__indirection, A_INDIRECTION, A_Indirection, a_indirection);
            break;
            case T_A_ArrayExpr:
            OUT_NODE(A_ArrayExpr, AArrayExpr, a__array_expr, A_ARRAY_EXPR, A_ArrayExpr, a_array_expr);
            break;
            case T_ResTarget:
            OUT_NODE(ResTarget, ResTarget, res_target, RES_TARGET, ResTarget, res_target);
            break;
            case T_MultiAssignRef:
            OUT_NODE(MultiAssignRef, MultiAssignRef, multi_assign_ref, MULTI_ASSIGN_REF, MultiAssignRef, multi_assign_ref);
            break;
            case T_SortBy:
            OUT_NODE(SortBy, SortBy, sort_by, SORT_BY, SortBy, sort_by);
            break;
            case T_WindowDef:
            OUT_NODE(WindowDef, WindowDef, window_def, WINDOW_DEF, WindowDef, window_def);
            break;
            case T_RangeSubselect:
            OUT_NODE(RangeSubselect, RangeSubselect, range_subselect, RANGE_SUBSELECT, RangeSubselect, range_subselect);
            break;
            case T_RangeFunction:
            OUT_NODE(RangeFunction, RangeFunction, range_function, RANGE_FUNCTION, RangeFunction, range_function);
            break;
            case T_RangeTableSample:
            OUT_NODE(RangeTableSample, RangeTableSample, range_table_sample, RANGE_TABLE_SAMPLE, RangeTableSample, range_table_sample);
            break;
            case T_ColumnDef:
            OUT_NODE(ColumnDef, ColumnDef, column_def, COLUMN_DEF, ColumnDef, column_def);
            break;
            case T_TableLikeClause:
            OUT_NODE(TableLikeClause, TableLikeClause, table_like_clause, TABLE_LIKE_CLAUSE, TableLikeClause, table_like_clause);
            break;
            case T_IndexElem:
            OUT_NODE(IndexElem, IndexElem, index_elem, INDEX_ELEM, IndexElem, index_elem);
            break;
            case T_DefElem:
            OUT_NODE(DefElem, DefElem, def_elem, DEF_ELEM, DefElem, def_elem);
            break;
            case T_LockingClause:
            OUT_NODE(LockingClause, LockingClause, locking_clause, LOCKING_CLAUSE, LockingClause, locking_clause);
            break;
            case T_XmlSerialize:
            OUT_NODE(XmlSerialize, XmlSerialize, xml_serialize, XML_SERIALIZE, XmlSerialize, xml_serialize);
            break;
            case T_PartitionElem:
            OUT_NODE(PartitionElem, PartitionElem, partition_elem, PARTITION_ELEM, PartitionElem, partition_elem);
            break;
            case T_PartitionSpec:
            OUT_NODE(PartitionSpec, PartitionSpec, partition_spec, PARTITION_SPEC, PartitionSpec, partition_spec);
            break;
            case T_PartitionBoundSpec:
            OUT_NODE(PartitionBoundSpec, PartitionBoundSpec, partition_bound_spec, PARTITION_BOUND_SPEC, PartitionBoundSpec, partition_bound_spec);
            break;
            case T_PartitionRangeDatum:
            OUT_NODE(PartitionRangeDatum, PartitionRangeDatum, partition_range_datum, PARTITION_RANGE_DATUM, PartitionRangeDatum, partition_range_datum);
            break;
            case T_RTEPermissionInfo:
            OUT_NODE(RTEPermissionInfo, RTEPermissionInfo, rtepermission_info, RTEPERMISSION_INFO, RTEPermissionInfo, rtepermission_info);
            break;
            case T_TableSampleClause:
            OUT_NODE(TableSampleClause, TableSampleClause, table_sample_clause, TABLE_SAMPLE_CLAUSE, TableSampleClause, table_sample_clause);
            break;
            case T_WithCheckOption:
            OUT_NODE(WithCheckOption, WithCheckOption, with_check_option, WITH_CHECK_OPTION, WithCheckOption, with_check_option);
            break;
            case T_SortGroupClause:
            OUT_NODE(SortGroupClause, SortGroupClause, sort_group_clause, SORT_GROUP_CLAUSE, SortGroupClause, sort_group_clause);
            break;
            case T_GroupingSet:
            OUT_NODE(GroupingSet, GroupingSet, grouping_set, GROUPING_SET, GroupingSet, grouping_set);
            break;
            case T_WindowClause:
            OUT_NODE(WindowClause, WindowClause, window_clause, WINDOW_CLAUSE, WindowClause, window_clause);
            break;
            case T_RowMarkClause:
            OUT_NODE(RowMarkClause, RowMarkClause, row_mark_clause, ROW_MARK_CLAUSE, RowMarkClause, row_mark_clause);
            break;
            case T_WithClause:
            OUT_NODE(WithClause, WithClause, with_clause, WITH_CLAUSE, WithClause, with_clause);
            break;
            case T_InferClause:
            OUT_NODE(InferClause, InferClause, infer_clause, INFER_CLAUSE, InferClause, infer_clause);
            break;
            case T_OnConflictClause:
            OUT_NODE(OnConflictClause, OnConflictClause, on_conflict_clause, ON_CONFLICT_CLAUSE, OnConflictClause, on_conflict_clause);
            break;
            case T_CTESearchClause:
            OUT_NODE(CTESearchClause, CTESearchClause, ctesearch_clause, CTESEARCH_CLAUSE, CTESearchClause, ctesearch_clause);
            break;
            case T_CTECycleClause:
            OUT_NODE(CTECycleClause, CTECycleClause, ctecycle_clause, CTECYCLE_CLAUSE, CTECycleClause, ctecycle_clause);
            break;
            case T_RawStmt:
            OUT_NODE(RawStmt, RawStmt, raw_stmt, RAW_STMT, RawStmt, raw_stmt);
            break;
            case T_SelectStmt:
            OUT_NODE(SelectStmt, SelectStmt, select_stmt, SELECT_STMT, SelectStmt, select_stmt);
            break;
            case T_SetOperationStmt:
            OUT_NODE(SetOperationStmt, SetOperationStmt, set_operation_stmt, SET_OPERATION_STMT, SetOperationStmt, set_operation_stmt);
            break;
            case T_ReturnStmt:
            OUT_NODE(ReturnStmt, ReturnStmt, return_stmt, RETURN_STMT, ReturnStmt, return_stmt);
            break;
            case T_PLAssignStmt:
            OUT_NODE(PLAssignStmt, PLAssignStmt, plassign_stmt, PLASSIGN_STMT, PLAssignStmt, plassign_stmt);
            break;
            case T_CreateSchemaStmt:
            OUT_NODE(CreateSchemaStmt, CreateSchemaStmt, create_schema_stmt, CREATE_SCHEMA_STMT, CreateSchemaStmt, create_schema_stmt);
            break;
            case T_AlterTableStmt:
            OUT_NODE(AlterTableStmt, AlterTableStmt, alter_table_stmt, ALTER_TABLE_STMT, AlterTableStmt, alter_table_stmt);
            break;
            case T_ReplicaIdentityStmt:
            OUT_NODE(ReplicaIdentityStmt, ReplicaIdentityStmt, replica_identity_stmt, REPLICA_IDENTITY_STMT, ReplicaIdentityStmt, replica_identity_stmt);
            break;
            case T_AlterCollationStmt:
            OUT_NODE(AlterCollationStmt, AlterCollationStmt, alter_collation_stmt, ALTER_COLLATION_STMT, AlterCollationStmt, alter_collation_stmt);
            break;
            case T_AlterDomainStmt:
            OUT_NODE(AlterDomainStmt, AlterDomainStmt, alter_domain_stmt, ALTER_DOMAIN_STMT, AlterDomainStmt, alter_domain_stmt);
            break;
            case T_GrantStmt:
            OUT_NODE(GrantStmt, GrantStmt, grant_stmt, GRANT_STMT, GrantStmt, grant_stmt);
            break;
            case T_ObjectWithArgs:
            OUT_NODE(ObjectWithArgs, ObjectWithArgs, object_with_args, OBJECT_WITH_ARGS, ObjectWithArgs, object_with_args);
            break;
            case T_AccessPriv:
            OUT_NODE(AccessPriv, AccessPriv, access_priv, ACCESS_PRIV, AccessPriv, access_priv);
            break;
            case T_GrantRoleStmt:
            OUT_NODE(GrantRoleStmt, GrantRoleStmt, grant_role_stmt, GRANT_ROLE_STMT, GrantRoleStmt, grant_role_stmt);
            break;
            case T_AlterDefaultPrivilegesStmt:
            OUT_NODE(AlterDefaultPrivilegesStmt, AlterDefaultPrivilegesStmt, alter_default_privileges_stmt, ALTER_DEFAULT_PRIVILEGES_STMT, AlterDefaultPrivilegesStmt, alter_default_privileges_stmt);
            break;
            case T_CopyStmt:
            OUT_NODE(CopyStmt, CopyStmt, copy_stmt, COPY_STMT, CopyStmt, copy_stmt);
            break;
            case T_VariableSetStmt:
            OUT_NODE(VariableSetStmt, VariableSetStmt, variable_set_stmt, VARIABLE_SET_STMT, VariableSetStmt, variable_set_stmt);
            break;
            case T_VariableShowStmt:
            OUT_NODE(VariableShowStmt, VariableShowStmt, variable_show_stmt, VARIABLE_SHOW_STMT, VariableShowStmt, variable_show_stmt);
            break;
            case T_CreateStmt:
            OUT_NODE(CreateStmt, CreateStmt, create_stmt, CREATE_STMT, CreateStmt, create_stmt);
            break;
            case T_Constraint:
            OUT_NODE(Constraint, Constraint, constraint, CONSTRAINT, Constraint, constraint);
            break;
            case T_CreateTableSpaceStmt:
            OUT_NODE(CreateTableSpaceStmt, CreateTableSpaceStmt, create_table_space_stmt, CREATE_TABLE_SPACE_STMT, CreateTableSpaceStmt, create_table_space_stmt);
            break;
            case T_DropTableSpaceStmt:
            OUT_NODE(DropTableSpaceStmt, DropTableSpaceStmt, drop_table_space_stmt, DROP_TABLE_SPACE_STMT, DropTableSpaceStmt, drop_table_space_stmt);
            break;
            case T_AlterTableSpaceOptionsStmt:
            OUT_NODE(AlterTableSpaceOptionsStmt, AlterTableSpaceOptionsStmt, alter_table_space_options_stmt, ALTER_TABLE_SPACE_OPTIONS_STMT, AlterTableSpaceOptionsStmt, alter_table_space_options_stmt);
            break;
            case T_AlterTableMoveAllStmt:
            OUT_NODE(AlterTableMoveAllStmt, AlterTableMoveAllStmt, alter_table_move_all_stmt, ALTER_TABLE_MOVE_ALL_STMT, AlterTableMoveAllStmt, alter_table_move_all_stmt);
            break;
            case T_CreateExtensionStmt:
            OUT_NODE(CreateExtensionStmt, CreateExtensionStmt, create_extension_stmt, CREATE_EXTENSION_STMT, CreateExtensionStmt, create_extension_stmt);
            break;
            case T_AlterExtensionStmt:
            OUT_NODE(AlterExtensionStmt, AlterExtensionStmt, alter_extension_stmt, ALTER_EXTENSION_STMT, AlterExtensionStmt, alter_extension_stmt);
            break;
            case T_AlterExtensionContentsStmt:
            OUT_NODE(AlterExtensionContentsStmt, AlterExtensionContentsStmt, alter_extension_contents_stmt, ALTER_EXTENSION_CONTENTS_STMT, AlterExtensionContentsStmt, alter_extension_contents_stmt);
            break;
            case T_CreateFdwStmt:
            OUT_NODE(CreateFdwStmt, CreateFdwStmt, create_fdw_stmt, CREATE_FDW_STMT, CreateFdwStmt, create_fdw_stmt);
            break;
            case T_AlterFdwStmt:
            OUT_NODE(AlterFdwStmt, AlterFdwStmt, alter_fdw_stmt, ALTER_FDW_STMT, AlterFdwStmt, alter_fdw_stmt);
            break;
            case T_CreateForeignServerStmt:
            OUT_NODE(CreateForeignServerStmt, CreateForeignServerStmt, create_foreign_server_stmt, CREATE_FOREIGN_SERVER_STMT, CreateForeignServerStmt, create_foreign_server_stmt);
            break;
            case T_AlterForeignServerStmt:
            OUT_NODE(AlterForeignServerStmt, AlterForeignServerStmt, alter_foreign_server_stmt, ALTER_FOREIGN_SERVER_STMT, AlterForeignServerStmt, alter_foreign_server_stmt);
            break;
            case T_CreateForeignTableStmt:
            OUT_NODE(CreateForeignTableStmt, CreateForeignTableStmt, create_foreign_table_stmt, CREATE_FOREIGN_TABLE_STMT, CreateForeignTableStmt, create_foreign_table_stmt);
            break;
            case T_AlterUserMappingStmt:
            OUT_NODE(AlterUserMappingStmt, AlterUserMappingStmt, alter_user_mapping_stmt, ALTER_USER_MAPPING_STMT, AlterUserMappingStmt, alter_user_mapping_stmt);
            break;
            case T_DropUserMappingStmt:
            OUT_NODE(DropUserMappingStmt, DropUserMappingStmt, drop_user_mapping_stmt, DROP_USER_MAPPING_STMT, DropUserMappingStmt, drop_user_mapping_stmt);
            break;
            case T_ImportForeignSchemaStmt:
            OUT_NODE(ImportForeignSchemaStmt, ImportForeignSchemaStmt, import_foreign_schema_stmt, IMPORT_FOREIGN_SCHEMA_STMT, ImportForeignSchemaStmt, import_foreign_schema_stmt);
            break;
            case T_CreatePolicyStmt:
            OUT_NODE(CreatePolicyStmt, CreatePolicyStmt, create_policy_stmt, CREATE_POLICY_STMT, CreatePolicyStmt, create_policy_stmt);
            break;
            case T_AlterPolicyStmt:
            OUT_NODE(AlterPolicyStmt, AlterPolicyStmt, alter_policy_stmt, ALTER_POLICY_STMT, AlterPolicyStmt, alter_policy_stmt);
            break;
            case T_CreateAmStmt:
            OUT_NODE(CreateAmStmt, CreateAmStmt, create_am_stmt, CREATE_AM_STMT, CreateAmStmt, create_am_stmt);
            break;
            case T_CreateTrigStmt:
            OUT_NODE(CreateTrigStmt, CreateTrigStmt, create_trig_stmt, CREATE_TRIG_STMT, CreateTrigStmt, create_trig_stmt);
            break;
            case T_CreateEventTrigStmt:
            OUT_NODE(CreateEventTrigStmt, CreateEventTrigStmt, create_event_trig_stmt, CREATE_EVENT_TRIG_STMT, CreateEventTrigStmt, create_event_trig_stmt);
            break;
            case T_AlterEventTrigStmt:
            OUT_NODE(AlterEventTrigStmt, AlterEventTrigStmt, alter_event_trig_stmt, ALTER_EVENT_TRIG_STMT, AlterEventTrigStmt, alter_event_trig_stmt);
            break;
            case T_CreatePLangStmt:
            OUT_NODE(CreatePLangStmt, CreatePLangStmt, create_plang_stmt, CREATE_PLANG_STMT, CreatePLangStmt, create_plang_stmt);
            break;
            case T_CreateRoleStmt:
            OUT_NODE(CreateRoleStmt, CreateRoleStmt, create_role_stmt, CREATE_ROLE_STMT, CreateRoleStmt, create_role_stmt);
            break;
            case T_AlterRoleStmt:
            OUT_NODE(AlterRoleStmt, AlterRoleStmt, alter_role_stmt, ALTER_ROLE_STMT, AlterRoleStmt, alter_role_stmt);
            break;
            case T_AlterRoleSetStmt:
            OUT_NODE(AlterRoleSetStmt, AlterRoleSetStmt, alter_role_set_stmt, ALTER_ROLE_SET_STMT, AlterRoleSetStmt, alter_role_set_stmt);
            break;
            case T_DropRoleStmt:
            OUT_NODE(DropRoleStmt, DropRoleStmt, drop_role_stmt, DROP_ROLE_STMT, DropRoleStmt, drop_role_stmt);
            break;
            case T_CreateSeqStmt:
            OUT_NODE(CreateSeqStmt, CreateSeqStmt, create_seq_stmt, CREATE_SEQ_STMT, CreateSeqStmt, create_seq_stmt);
            break;
            case T_AlterSeqStmt:
            OUT_NODE(AlterSeqStmt, AlterSeqStmt, alter_seq_stmt, ALTER_SEQ_STMT, AlterSeqStmt, alter_seq_stmt);
            break;
            case T_DefineStmt:
            OUT_NODE(DefineStmt, DefineStmt, define_stmt, DEFINE_STMT, DefineStmt, define_stmt);
            break;
            case T_CreateDomainStmt:
            OUT_NODE(CreateDomainStmt, CreateDomainStmt, create_domain_stmt, CREATE_DOMAIN_STMT, CreateDomainStmt, create_domain_stmt);
            break;
            case T_CreateOpClassStmt:
            OUT_NODE(CreateOpClassStmt, CreateOpClassStmt, create_op_class_stmt, CREATE_OP_CLASS_STMT, CreateOpClassStmt, create_op_class_stmt);
            break;
            case T_CreateOpClassItem:
            OUT_NODE(CreateOpClassItem, CreateOpClassItem, create_op_class_item, CREATE_OP_CLASS_ITEM, CreateOpClassItem, create_op_class_item);
            break;
            case T_CreateOpFamilyStmt:
            OUT_NODE(CreateOpFamilyStmt, CreateOpFamilyStmt, create_op_family_stmt, CREATE_OP_FAMILY_STMT, CreateOpFamilyStmt, create_op_family_stmt);
            break;
            case T_AlterOpFamilyStmt:
            OUT_NODE(AlterOpFamilyStmt, AlterOpFamilyStmt, alter_op_family_stmt, ALTER_OP_FAMILY_STMT, AlterOpFamilyStmt, alter_op_family_stmt);
            break;
            case T_DropStmt:
            OUT_NODE(DropStmt, DropStmt, drop_stmt, DROP_STMT, DropStmt, drop_stmt);
            break;
            case T_TruncateStmt:
            OUT_NODE(TruncateStmt, TruncateStmt, truncate_stmt, TRUNCATE_STMT, TruncateStmt, truncate_stmt);
            break;
            case T_CommentStmt:
            OUT_NODE(CommentStmt, CommentStmt, comment_stmt, COMMENT_STMT, CommentStmt, comment_stmt);
            break;
            case T_SecLabelStmt:
            OUT_NODE(SecLabelStmt, SecLabelStmt, sec_label_stmt, SEC_LABEL_STMT, SecLabelStmt, sec_label_stmt);
            break;
            case T_DeclareCursorStmt:
            OUT_NODE(DeclareCursorStmt, DeclareCursorStmt, declare_cursor_stmt, DECLARE_CURSOR_STMT, DeclareCursorStmt, declare_cursor_stmt);
            break;
            case T_ClosePortalStmt:
            OUT_NODE(ClosePortalStmt, ClosePortalStmt, close_portal_stmt, CLOSE_PORTAL_STMT, ClosePortalStmt, close_portal_stmt);
            break;
            case T_FetchStmt:
            OUT_NODE(FetchStmt, FetchStmt, fetch_stmt, FETCH_STMT, FetchStmt, fetch_stmt);
            break;
            case T_IndexStmt:
            OUT_NODE(IndexStmt, IndexStmt, index_stmt, INDEX_STMT, IndexStmt, index_stmt);
            break;
            case T_CreateStatsStmt:
            OUT_NODE(CreateStatsStmt, CreateStatsStmt, create_stats_stmt, CREATE_STATS_STMT, CreateStatsStmt, create_stats_stmt);
            break;
            case T_StatsElem:
            OUT_NODE(StatsElem, StatsElem, stats_elem, STATS_ELEM, StatsElem, stats_elem);
            break;
            case T_CreateFunctionStmt:
            OUT_NODE(CreateFunctionStmt, CreateFunctionStmt, create_function_stmt, CREATE_FUNCTION_STMT, CreateFunctionStmt, create_function_stmt);
            break;
            case T_FunctionParameter:
            OUT_NODE(FunctionParameter, FunctionParameter, function_parameter, FUNCTION_PARAMETER, FunctionParameter, function_parameter);
            break;
            case T_AlterFunctionStmt:
            OUT_NODE(AlterFunctionStmt, AlterFunctionStmt, alter_function_stmt, ALTER_FUNCTION_STMT, AlterFunctionStmt, alter_function_stmt);
            break;
            case T_DoStmt:
            OUT_NODE(DoStmt, DoStmt, do_stmt, DO_STMT, DoStmt, do_stmt);
            break;
            case T_InlineCodeBlock:
            OUT_NODE(InlineCodeBlock, InlineCodeBlock, inline_code_block, INLINE_CODE_BLOCK, InlineCodeBlock, inline_code_block);
            break;
            case T_CallContext:
            OUT_NODE(CallContext, CallContext, call_context, CALL_CONTEXT, CallContext, call_context);
            break;
            case T_RenameStmt:
            OUT_NODE(RenameStmt, RenameStmt, rename_stmt, RENAME_STMT, RenameStmt, rename_stmt);
            break;
            case T_AlterObjectDependsStmt:
            OUT_NODE(AlterObjectDependsStmt, AlterObjectDependsStmt, alter_object_depends_stmt, ALTER_OBJECT_DEPENDS_STMT, AlterObjectDependsStmt, alter_object_depends_stmt);
            break;
            case T_ExecuteStmt:
            OUT_NODE(ExecuteStmt, ExecuteStmt, execute_stmt, EXECUTE_STMT, ExecuteStmt, execute_stmt);
            break;
			default:
				elog(WARNING, "could not dump unrecognized node type: %d",
					 (int) nodeTag(obj));

				appendStringInfo(out, "}");
				return;
		}
		removeTrailingDelimiter(out);
		appendStringInfo(out, "}}");
	}
}

char *
pg_query_node_to_json(const void *obj)
{
	StringInfoData out;

	initStringInfo(&out);
	_outNode(&out, obj);

	return out.data;
}

char *
pg_query_nodes_to_json(const void *obj)
{
	StringInfoData out;
	const ListCell *lc;

	initStringInfo(&out);

	if (obj == NULL) /* Make sure we generate valid JSON for empty queries */
	{
		appendStringInfo(&out, "{\"version\":%d,\"stmts\":[]}", PG_VERSION_NUM);
	}
	else
	{
		appendStringInfoString(&out, "{");
		appendStringInfo(&out, "\"version\":%d,", PG_VERSION_NUM);
		appendStringInfoString(&out, "\"stmts\":");
		appendStringInfoChar(&out, '[');

		foreach(lc, obj)
		{
			appendStringInfoChar(&out, '{');
			_outRawStmt(&out, lfirst(lc));
			removeTrailingDelimiter(&out);
			appendStringInfoChar(&out, '}');

			if (lnext(obj, lc))
				appendStringInfoString(&out, ",");
		}

		appendStringInfoChar(&out, ']');
		appendStringInfoString(&out, "}");
	}

	return out.data;
}

char *
nodeToJson(const void *obj)
{
    return pg_query_nodes_to_json(obj);
}
